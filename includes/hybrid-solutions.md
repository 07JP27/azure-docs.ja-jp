#Azure のサービス バス

クラウドで実行されるソフトウェアも、内部設置型のソフトウェアも、一般的には他のソフトウェアと対話する必要があります。この必要性に広範に対応するために、Azure には Service Bus が用意されています。この記事ではこのテクノロジを中心に、その内容とそれを使用する理由について説明します。

##目次      
- [Service Bus の基礎](#fundamentals)
- [キュー](#queues)
- [トピック](#topics)
- [リレー](#relays)


## <a name="fundamentals"></a>Service Bus の基礎
状況が異なれば、求められる通信のスタイルも異なります。アプリケーションが単純なキューを介してメッセージを送受信する方法が最適なソリューションであることもあります。逆に、通常のキューでは不十分で、発行とサブスクライブのメカニズムを備えたキューを使用する方が適していることもあります。場合によっては、アプリケーション間の接続のみが必要で、キューは不必要なこともあります。Service Bus はこれらの 3 つのオプションすべてを提供し、アプリケーションがさまざまな方法で対話できるようにします。

Service Bus は、サービスが複数のユーザーによって共有されるマルチテナント クラウド サービスです。各ユーザー (たとえば、アプリケーション開発者) は、*"名前空間"* を作成し、その名前空間内で必要な通信メカニズムを定義します。[図 1](#Fig1) にこのしくみを示します。

<a name="Fig1"></a>![Diagram of Azure Service Bus][svc-bus]
 
**図 1: Service Bus は、クラウドを介してアプリケーションを接続するためのマルチテナント サービスを提供する**

名前空間内では、3 つの異なる通信メカニズムの 1 つまたは複数のインスタンスを使用して、それぞれ異なる方法でアプリケーションを接続できます。選択肢は以下のとおりです。

- *"キュー"*: 一方向の通信を提供します。それぞれのキューは、送信されたメッセージが受信されるまでメッセージを格納する仲介者 (*"ブローカー"* とも呼ばれます) として動作します。
- *"トピック"*: *"サブスクリプション"* を使用して一方向の通信を提供します。キューと同様、トピックはブローカーとして動作しますが、サブスクリプションは特定の条件に一致するメッセージのみを認識します。
- *"リレー"*: 双方向の通信を提供します。キューやトピックと異なり、リレーはブローカーではなく、転送中のメッセージを格納しません。送信先のアプリケーションにメッセージを渡すのみです。

作成したキュー、トピック、またはリレーには名前を付けます。名前空間に付けた名前とこの名前の組み合わせが、オブジェクトの一意の識別子となります。この名前を サービス バスに通知すると、アプリケーションは、キュー、トピック、またはリレーを使用して通信を行うことができます。 

これらのいずれかのオブジェクトを使用するために、Windows アプリケーションは Windows Communication Foundation (WCF) を使用できます。キューとトピックに対しては、Windows アプリケーションは、サービス バスによって定義されたメッセージング API を使用することもできます。キューとトピックは、HTTP を介してアクセスすることもできます。Microsoft では、非 Windows アプリケーションからこれらを簡単に利用できるように、Java、Node.js、およびその他の言語向けの SDK を提供しています。

Service Bus 自体はクラウド (つまり、Microsoft の Azure データセンター) で実行されますが、Service Bus を使用するアプリケーションはどのような場所でも実行できることを理解しておいてください。Service Bus を使用すると、たとえば、Azure 上で実行されているアプリケーションや、自社のデータセンター内で実行されているアプリケーションを接続できます。Azure または他のクラウド プラットフォーム上で実行されているアプリケーションを、オンプレミスのアプリケーション、タブレット、または携帯電話と接続することもできます。さらに、家電製品、センサーなどのデバイスを中央アプリケーションに接続したり、デバイスを相互接続したりできます。サービス バスは、あらゆる場所から利用できる、クラウドを使った汎用通信メカニズムです。Service Bus の利用方法は、アプリケーションで何を行う必要があるかによって決まります。


## <a name="queues"></a>キュー

Service Bus キューを使用して 2 つのアプリケーションを接続するとします。[図 2](#Fig2) に、この状況を示します。

<a name="Fig2"></a>![Diagram of Service Bus Queues][キュー]
 
**図 2: Service Bus キューは一方向の非同期キューを提供する**

この場合のプロセスは単純です。送信者がメッセージを Service Bus キューに送信すると、受信者が後でそのメッセージを取得します。[図 2](#Fig2) に示すように、キューの受信者は 1 つのみです。また、複数のアプリケーションが同じキューから読み取ることもできます。後者のケースでは、通常、各メッセージは 1 つの受信者によって読み取られます。つまり、キューはマルチキャスト サービスを提供しません。

それぞれのメッセージは、2 つの部分から構成されます。つまり、それぞれがキーと値のペアであるプロパティのセットと、バイナリ メッセージ本文です。これらの使用方法は、アプリケーションの目的によって決まります。たとえば、最近の売り上げに関するメッセージを送信するアプリケーションでは、*Seller="Ava"*、*Amount=10000* などのプロパティが含まれます。メッセージ本文には、たとえば営業部の署名済みの契約書のスキャン画像を含めることが考えられます。画像がない場合はメッセージ本文が空になります。

受信者は、2 つの異なる方法で Service Bus キューからメッセージを読み取ることができます。1 つのオプションは ReceiveAndDelete です。このオプションでは、メッセージをキューから取り出した直後に削除します。この方法は単純ですが、メッセージを処理する前に受信者がクラッシュした場合はメッセージが失われます。メッセージはキューから削除されているため、他の受信者がメッセージにアクセスすることもできません。 

もう 1 つのオプションである PeekLock は、この問題に対処できます。ReceiveAndDelete と同様、PeekLock 読み取りを実行すると、メッセージがキューから削除されます。ただし、実際に削除する前に、メッセージをロックして他の受信者が認識できないようにして、次の 3 つのイベントのいずれかの発生を待ちます。

- 受信者がメッセージを正常に処理し、Complete を呼び出すと、キューのメッセージが削除されます。 
- 受信者がメッセージを正常に処理できないと判断すると、Abandon を呼び出します。すると、キューのメッセージのロックが解除され、他の受信者がメッセージを取得できるようになります。
- 受信者が一定の時間内 (構成可能、既定では 60 秒) にどちらも呼び出さなかった場合、その受信者は失敗したと見なされます。その場合、その受信者が Abandon を呼び出した場合と同様に処理され、他の受信者がメッセージを取得できるようになります。

ここで考えられるのは、同じメッセージが 2 回、2 つの異なる受信者に配信される可能性があることです。そのため、サービス バス キューを使用するアプリケーションでは、この問題に対処する必要があります。重複の検出を容易にするために、各メッセージは一意の MessageID プロパティを持ちます。このプロパティは、メッセージがキューから何回読み取られようとも、既定で同じ値に保持されます。 

キューは、さまざまな状況で利用できます。同時に実行されていないアプリケーション間でも相互に通信することができます。これは、バッチおよびモバイル アプリケーションで特に便利な機能です。受信者が複数のキューでは、送信されたメッセージが受信者に分散されるため、自動負荷分散も実現されます。


## <a name="topics"></a>トピック

キューは、便利ではありますが、常に適切なソリューションとは限りません。サービス バス トピックの方が適切な場合もあります。[図 3](#Fig3) に、その理由を示します。

<a name="Fig3"></a>![Diagram of Service Bus Topics and Subscriptions][topics-subs]
 
**図 3: サブスクライブ アプリケーションが指定するフィルターに基づき、Service Bus トピックに送信された一部またはすべてのメッセージを受信できる**

トピックは、多くの点でキューに似ています。送信者は、キューに送信する場合と同じ方法でメッセージをトピックに送信します。これらのメッセージは、キューの場合と同じに見えます。大きな違いは、トピックでは、受信側アプリケーションごとに *f"フィルター"*f を定義することで独自のサブスクリプションを作成できる点です。サブスクライバーは、そのフィルターに一致するメッセージのみを識別します。[図 3](#Fig3) に、1 つの送信者と、3 つのサブスクライバーを持つトピックの例を示します。各サブスクライバーにはそれぞれ独自のフィルターが設定されています。

- サブスクライバー 1 は、*Seller="Ava"* というプロパティを含むメッセージのみを受信します。
- サブスクライバー 2 は、*Seller="Ruby"* というプロパティを含むか、*Amount* プロパティの値が 100,000 を超えるメッセージを受信します。Ruby はセールス マネージャーであるため、自分の売り上げと、担当者を問わずすべての大きな売り上げを確認することを目的としています。
- サブスクライバー 3 のフィルターは *True* に設定されています。これは、すべてのメッセージを受信することを表します。このアプリケーションは、たとえば監査証跡を維持する目的で使用されることが考えられるため、すべてのメッセージを認識する必要があります。

キューの場合と同様、トピックのサブスクライバーは、ReceiveAndDelete または PeekLock を使用してメッセージを読み取ることができます。ただし、キューとは異なり、1 つのトピックに送信された 1 つのメッセージを複数のサブスクライバーで受信できます。この手法は一般的に *"発行とサブスクライブ"* と呼ばれ、同じメッセージを複数のアプリケーションで利用する可能性がある場合に便利です。適切なフィルターを定義することで、各サブスクライバーは、メッセージ ストリームの中で認識する必要がある部分のみを利用できます。


## <a name="relays"></a>リレー

キューとトピックは、どちらもブローカーを介して一方向の非同期通信を提供します。トラフィックは一方向に流れ、送信者と受信者の間に直接的な接続はありません。しかし、それが適切でない状況もあります。アプリケーションが送受信を行う必要がある場合や、アプリケーション間の直接リンクが必要な場合、中間にメッセージを格納する場所は必要ありません。このような問題に対応するために、Service Bus にはリレーが用意されています。[図 4](#Fig4) を参照してください。

<a name="Fig4"></a>![Diagram of Service Bus Relay][リレー]
 
**図 4: Service Bus リレーはアプリケーション間の同期双方向通信を提供する**

リレーに関する素朴な疑問は、なぜリレーを使用するのか、ということでしょう。キューが不要な場合でも、アプリケーションが直接対話するのではなくクラウド サービス経由で通信を行うのはなぜでしょうか。それは、直接的な通信が思いのほか難しいためです。

たとえば、会社の別々のデータセンター内で実行されている 2 つの内部設置型アプリケーションを接続するとします。どちらのアプリケーションもファイアウォールの背後に配置され、それぞれのデータセンターでネットワーク アドレス変換 (NAT) が使用されているとします。ファイアウォールにより、特定のポート以外のポートの着信データはすべてブロックされます。また、NAT が使用されているということは、それぞれのアプリケーションが実行されているコンピューターに固定 IP アドレスが割り当てられていないことを意味します。特別な手段がなければ、2 つのアプリケーションをパブリックなインターネット経由で接続することは困難です。

Service Bus リレーは、この問題を解決するのに役立ちます。リレーを介して双方向の通信を行うために、それぞれのアプリケーションは サービス バスとの間で送信 TCP 接続を確立し、接続を開いたまま保持します。2 つのアプリケーション間のすべての通信はこの接続を介して行われます。それぞれの接続はデータセンター内から確立されているため、ファイアウォールは、新しいポートを開くことなく、各アプリケーションへの着信トラフィック (リレーを介して送信されたデータ) を許可します。この方法では、各アプリケーションは通信において一貫したエンドポイントを持つため、NAT の問題にも対処できます。リレーを介してデータを交換することで、アプリケーションは、それ以外の方法では通信を困難にする問題を回避できます。 

Service Bus リレーを使用する場合、アプリケーションは Windows Communication Foundation (WCF) に依存します。サービス バスには WCF バインディングが用意されているため、Windows アプリケーションは容易にリレー経由で対話できます。通常、WCF を既に使用しているアプリケーションでは、これらのバインディングのいずれかを指定するだけで、リレーを介して他のアプリケーションと通信を行うことができます。非 Windows アプリケーションからリレーを使用することもできますが、キューやトピックとは異なり、プログラム上の工夫が必要になります。標準ライブラリは用意されていません。

キューやトピックとは異なり、アプリケーションは明示的にリレーを作成しません。リレーは、メッセージを受信する側のアプリケーションが サービス バスとの間に TCP 接続を確立したときに自動的に作成されます。接続がドロップされると、リレーは削除されます。特定のリスナーによって作成されたリレーをアプリケーションが検出できるようにレジストリが用意されており、特定のリレーを名前で見つけることができます。

リレーは、直接的な通信が必要な場合に適したソリューションです。たとえば、内部設置型データセンターで実行される航空券予約システムがあるとします。このシステムには、たとえばチェックイン受付機、モバイル デバイス、その他のコンピューターからアクセスできる必要があります。これらのすべてのシステムで実行されているアプリケーションが、クラウド上の Service Bus リレーを使用して、実行中は常時通信することができます。

完結したソリューションの構築において、アプリケーションの接続は不可欠な要素ですが、この問題を完全に解消することは困難です。Service Bus は、キュー、トピック、およびリレーを介してアプリケーションの接続を実現するクラウド ベースのテクノロジを提供し、この必須の機能をより簡単に、より広範に利用できるようにすることを目的としています。

[svc-bus]: ./media/hybrid-solutions/SvcBus_01_architecture.png
[queues]: ./media/hybrid-solutions/SvcBus_02_queues.png
[topics-subs]: ./media/hybrid-solutions/SvcBus_03_topicsandsubscriptions.png
[relay]: ./media/hybrid-solutions/SvcBus_04_relay.png
