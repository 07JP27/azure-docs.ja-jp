<properties
   pageTitle="Azure Active Directory (AD) での OAuth2 の暗黙的な許可フローについて | Microsoft Azure"
   description="OAuth2 の暗黙的な許可フローの Azure Active Directory の実装の詳細と、これが適切なアプリケーションについて説明します。"
   services="active-directory"
   documentationCenter="dev-center-name"
   authors="vibronet"
   manager="mbaldwin"
   editor=""/>

<tags
   ms.service="active-directory"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="identity"
   ms.date="06/01/2016"
   ms.author="vittorib;bryanla"/>

# Azure Active Directory (AD) での OAuth2 の暗黙的な許可フローについて

OAuth2 の暗黙的な許可は、OAuth2 仕様のセキュリティ問題を最も多く含むアクセス許可であることで知られています。それでも、ADAL JS によって実装されるアプローチであり、SPA アプリケーションを作成するときにお勧めするアプローチでもあります。何のためでしょう。 これはすべてトレードオフの問題です。結局のところ、暗黙的な許可が、ブラウザーで JavaScript を使用して Web API を使用するアプリケーションのために行うことができる最善のアプローチだからです。

## OAuth2 の暗黙的な許可とは

典型的な [OAuth2 認証コード付与](https://tools.ietf.org/html/rfc6749#section-1.3.1)は、2 つの別個のエンドポイントを使用する認証付与です。承認エンドポイントはユーザーとの対話段階で使用され、認証コードが生成されます。続いて、トークン エンドポイントが、アクセス トークンと多くの場合は更新トークンを交換するためクライアントによって使用されます。Web アプリケーションは、承認サーバーがクライアントを認証できるように、トークン エンドポイントに独自のアプリケーション資格情報を示す必要があります。

[OAuth2 の暗黙的な許可](https://tools.ietf.org/html/rfc6749#section-1.3.2)は、クライアントがアクセス トークン ([OpenId Connect](http://openid.net/specs/openid-connect-core-1_0.html) の場合は id\_token) を承認エンドポイントから直接取得するバリアントとして定義されます。トークン エンドポイントにアクセスしたり、クライアント アプリケーションを認証する必要はありません。このバリアントは、特に Web ブラウザーで実行される JavaScript ベース アプリのために設計されています。元の OAuth2 仕様では、トークンは URI フラグメントとして返されます。これにより、クライアントの JavaScript コードでトークン ビットを使用できるようになりますが、サーバーへのリダイレクトには含まれないことが保証されます。承認エンドポイントから直接ブラウザーのリダイレクトを使用してトークンを返すことには、クロス オリジン呼び出しに関する要件がなくなるという利点があります。クロス オリジン呼び出しは、JavaScript アプリがトークン エンドポイントにアクセスする必要がある場合に必要になります。

OAuth2 の暗黙的な許可の重要な特性は、このフローでクライアントに更新トークンが返されないという事実です。次のセクションで説明するとおり、これは本当は必要なく、実際にはセキュリティ上の問題になることがあります。

## OAuth2 の暗黙的な許可の適切なシナリオ

OAuth2 の仕様自体で明らかにされているとおり、暗黙的な許可はユーザー エージェント アプリケーション (つまり、ブラウザー内で実行される JavaScript アプリ) を有効にするために考案されました。このようなアプリの定義の特性として、サーバー リソース (通常は Web API) にアクセスするため、そしてアプリケーション UX を適切に更新するために、JavaScript コードが使用されます。Gmail や Outlook Web Access のようなアプリケーションを考えてみてください。受信トレイからメッセージを選択したときに、メッセージ視覚化パネルのみが変更されて新しい選択内容が表示され、ページの残りの部分は変更されません。これは、ユーザー操作ごとにページ全体がポストバックされて新しいサーバー応答によりページ全体がレンダリングされる、従来のリダイレクト ベースの Web アプリとは対照的です。

JavaScript ベースのアプローチを極端なほど採用するアプリケーションを、シングル ページ アプリケーション (SPA) と呼びます。この考え方では、アプリは最初の HTML ページと関連する JavaScript のみに作用し、後続のすべての対話は、JavaScript を介して実行される Web API 呼び出しによって行われます。ただし、ハイブリッド アプローチも珍しくはありません。このアプローチでは、アプリはほとんどの場合ポストバックに基づきますが、一部のエクスペリエンスを実装するために JS 呼び出しを実行することもあります。暗黙的フローの使用方法に関するディスカッションは、ハイブリッド アプローチにも関係します。

リダイレクト ベースのアプリケーションでは通常 Cookie を使用して要求をセキュリティで保護します。ただし、Cookie はその生成元のドメインに対してのみ機能しますが、JavaScript 呼び出しは他のドメインにリダイレクトされることがあると仮定すると、このアプローチは JavaScript アプリケーションでは同じように機能しません。実際、非常に多くの場合、この仮定が該当します。Microsoft Graph API、Office API、Azure API を呼び出すアプリケーションを考えてみてください。これらの API はすべて、アプリが動作するドメインの外部にあります。JavaScript アプリケーションでは、バックエンドを一切持たず、サード パーティの Web API に 100% 依存してビジネス機能を実装する傾向が強まっています。

現時点では、Web API 呼び出しを保護する推奨される方法は、OAuth2 のベアラー トークン アプローチを使用することです。このアプローチでは、すべての呼び出しに OAuth2 のアクセス トークンを付けます。Web API は受信したアクセス トークンを調べ、アクセス トークン内に必要なスコープが見つかった場合に、要求された操作へのアクセス許可を付与します。暗黙的フローは、JavaScript アプリが Web API 用のアクセス トークンを取得するための便利なメカニズムを提供することで、Cookie についてさまざまなメリットがあります。

- クロス オリジン呼び出しをしなくても、トークンを確実に取得できます。トークンが返されるリダイレクト URI の登録が必須であるため、トークンが置換されないことが保証されます。
- JavaScript アプリは、ドメイン制限なしで、対象とする Web API の数だけ、必要な数のアクセス トークンを取得できます。
- セッションやローカル ストレージなどの HTML5 機能ではトークンのキャッシュと有効期間管理にフル コントロールを許可しますが、Cookie の管理はアプリにとって非透過的です。
- アクセス トークンはクロスサイト リクエスト フォージェリ (CSRF) 攻撃をあまり受けません。

暗黙的な許可フローでは、主にセキュリティ上の理由から、更新トークンを発行しません。更新トークンはアクセス トークンほどスコープが狭義ではないため、多くの権限を付与すると、リークされた場合のダメージが大きくなります。暗黙的フローでは、トークンは URL の形式で配信されるため、傍受されるリスクが認証コード付与よりも高くなります。

ただし、JavaScript アプリケーションには、ユーザーに資格情報を繰り返し求めずにアクセス トークンを更新するための、自由に使用可能な別のメカニズムがあることに注意してください。アプリケーションは非表示の iframe を使用して、Azure AD の承認エンドポイントに対して新しいトークン要求を実行します。ブラウザーが Azure AD ドメインに対してアクティブなセッション (読み取り: セッション Cookie あり) を持っている限り、この認証要求は正常に行われ、ユーザーの操作は必要ありません。

このモデルは、JavaScript アプリに、更新トークンなどの高価値のアーティファクトを取得、管理、および保護する負担を増やさずにアクセス トークンを個別に更新でき、新しい API の新しいアクセス トークンも取得できる (ただしユーザーが事前に同意している場合) 能力を与えます。サイレント更新を可能にするアーティファクト、Azure AD のセッション Cookie は、アプリケーションの外部で管理されます。このアプローチのもう 1 つの利点は、ユーザーがブラウザー タブのいずれかで実行されている Azure AD を使用するいずれかのアプリケーションの Azure AD からサインアウトすると、Azure AD のセッション Cookie が削除され、サインアウトしたユーザーのトークンを更新する能力が JavaScript アプリから自動的に失われることです。

## 暗黙的な許可に適切なアプリ

暗黙的な許可では、他の許可方法よりも多くのリスクが生じます。注意を払う必要がある領域が詳しく解説されています (たとえば「[Misuse of Access Token to Impersonate Resource Owner in Implicit Flow (暗黙的フローでの偽装リソース所有者に対するアクセス トークンの誤用)][OAuth2-Spec-Implicit-Misuse]」、「[OAuth 2.0 Threat Model and Security Considerations (OAuth 2.0 の脅威モデルとセキュリティの考慮事項)][OAuth2-Threat-Model-And-Security-Implications]」などを参照)。ただし、よりリスクが高いプロファイルは、多くの場合、リモート リソースによってブラウザーに対して処理されるアクティブ コードを実行するアプリケーションを有効にしなければならないという事実に起因します。SPA アーキテクチャを選択していて、バックエンド コンポーネントがない場合、または一般的には JavaScript を使用して Web API を呼び出そうとしている場合は、トークンの取得に暗黙的フローを使用することをお勧めします。

アプリケーションがネイティブ クライアントの場合は、暗黙的フローはあまり向いていません。ネイティブ クライアントのコンテキストには Azure AD のセッション Cookie がないので、アプリには存続期間の長いセッションを維持し、ユーザーに繰り返し求めることなく新しいリソースのアクセス トークンを取得する手段がありません。

バックエンドを含む、つまり、バックエンド コードから API を使用する Web アプリケーションを開発する場合も、暗黙的フローはあまり向いていません。他の方法のほうがはるかに多くの能力を付与できます。たとえば、OAuth2 クライアント資格情報付与では、ユーザー委任とは対照的に、アプリ自体に割り当てられているアクセス許可を反映したトークンを取得する能力が与えられます (ユーザー委任は、ユーザーがセッションにアクティブに関与していない場合でもプログラムによるリソース アクセスを維持できる能力です)。それだけでなく、このような付与により、セキュリティ保証が強化されます。たとえば、アクセス トークンがユーザーのブラウザーを通過せず、ブラウザーの履歴に保存されるなどのリスクがありません。また、クライアント アプリケーションは、トークンを要求するときに強力な認証を実行できます。

## 次のステップ

- プロトコルの完全なセットや、Azure AD によってサポートされる OAuth2 認証付与フローなどの開発者向けリソースの一覧については、「[Azure AD 開発者ガイド][AAD-Developers-Guide]」を参照してください。
- アプリケーションの統合プロセスの詳細については、[アプリケーションを Azure AD と統合する方法についてのページ][ACOM-How-To-Integrate]を参照してください。

<!--Image references-->
[Scenario-Topology]: ./media/active-directory-devhowto-auth-using-any-aad/multi-tenant-aad-components.png

<!--Reference style links in use-->
[AAD-Developers-Guide]: active-directory-developers-guide.md
[ACOM-How-And-Why-Apps-Added-To-AAD]: active-directory-how-applications-are-added.md
[ACOM-How-To-Integrate]: active-directory-how-to-integrate.md
[OAuth2-Spec-Implicit-Misuse]: https://tools.ietf.org/html/rfc6749#section-10.16
[OAuth2-Threat-Model-And-Security-Implications]: https://tools.ietf.org/html/rfc6819

<!---HONumber=AcomDC_0601_2016-->