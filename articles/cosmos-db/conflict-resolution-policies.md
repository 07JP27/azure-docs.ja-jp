---
title: Azure Cosmos DB での競合解決の種類と解決ポリシー
description: この記事では、Azure Cosmos DB の競合カテゴリと競合解決ポリシーについて説明します。
services: cosmos-db
author: markjbrown
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 10/26/2018
ms.author: mjbrown
ms.openlocfilehash: c682b61a39224f2c80db8fe5fa153ea5e5d82922
ms.sourcegitcommit: ada7419db9d03de550fbadf2f2bb2670c95cdb21
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/02/2018
ms.locfileid: "50958571"
---
# <a name="conflict-types-and-resolution-policies"></a>競合のタイプと解決ポリシー

競合と競合解決ポリシーは、複数の書き込みリージョンを使用して Cosmos アカウントが構成されている場合に該当します。

複数の書き込みリージョンで構成されている Cosmos DB アカウントの場合、複数のライターが複数のリージョンで同じ項目を同時に更新するときに更新の競合が発生します。 更新の競合は次の 3 種類に分類されます。

1. **挿入の競合:** アプリケーションが同じ一意のインデックス (ID プロパティなど) を持つ複数の項目を複数のリージョンから同時に挿入した場合に発生することがあります。 この場合、最初はそれぞれのローカル リージョンですべての書き込みが成功する可能性がありますが、選択した競合解決ポリシーに基づいて、元の ID を持つ 1 つの項目のみが最終的にコミットされます。

1. **置換の競合:** アプリケーションが複数のリージョンから 1 つの項目を同時に更新するときに発生することがあります。

1. **削除の競合:** アプリケーションが 1 つのリージョンから項目を削除し、同時に他の任意のリージョンから項目を更新するときに発生することがあります。

## <a name="conflict-resolution-policies"></a>競合解決ポリシー

Cosmos DB では、更新の競合を解決するための柔軟なポリシー主導のメカニズムを提供します。 Cosmos のコンテナーでは、次の 2 つの競合解決ポリシーから選択できます。

- **最後の書き込みが有効 (LWW):**  この解決ポリシーでは、ユーザーはシステム定義のタイムスタンプ プロパティを既定で使用します (時刻同期クロック プロパティに基づきます)。 または、SQL API を使用しているときは、Cosmos DB で競合の解決に使用される他のカスタム数値プロパティ ("競合の解決パス" とも呼ばれる) を指定することもできます。  

  2 つ以上の項目が挿入または置換操作で競合する場合、「競合の解決パス」で最も高い値を持つ項目が「勝者」になります。 複数の項目が競合の解決パスで同じ数値を持つ場合、選択される「勝者」はシステムによって決定されます。 すべてのリージョンは単一の勝者に収束し、結果として同じバージョンのコミット済み項目になることが保証されます。 削除の競合がある場合、削除されるバージョンは、競合解決パスの値に関係なく挿入または置換の競合よりも常に優先されます。

  > [!NOTE]
  > 最後の書き込みが有効は既定の競合解決ポリシーであり、SQL、Table、MongoDB、Cassandra、および Gremlin API アカウントで使用できます。

  詳細については、[LWW 競合解決ポリシーの使用例](how-to-manage-conflicts.md#create-a-last-writer-wins-conflict-resolution-policy)に関する記事を参照してください。

- **カスタム**: この解決ポリシーは、競合の調整のためのアプリケーション定義のセマンティクス用に設計されています。 Cosmos コンテナーにこのポリシーを設定した場合、マージ ストアド プロシージャも登録する必要があります。このプロシージャは、サーバーのデータベース トランザクションで更新の競合が検出されたときに自動的に呼び出されます。 システムにより、コミットメント プロトコルの一部としてマージ プロシージャの実行が 1 回だけとなることが保証されます。  

  ただし、カスタム解決オプションを使用してコンテナーを構成するが、コンテナーに対してマージ プロシージャの登録に失敗するか、またはマージ プロシージャが実行時に例外をスローする場合、競合は競合フィードに書き込まれます。 このときアプリケーションは、競合フィード内で競合を手動で解決する必要があります。 詳細については、[カスタム解決ポリシーの使用と競合フィードを使用する方法の例](how-to-manage-conflicts.md#create-a-last-writer-wins-conflict-resolution-policy)に関する記事を参照してください。

  > [!NOTE]
  > カスタム競合解決ポリシーは、SQL API アカウントでのみ使用できます。

## <a name="next-steps"></a>次の手順

次に、次の記事を使用して、競合解決ポリシーを構成する方法を学習できます。

* [LWW 競合解決ポリシーを使用する方法](how-to-manage-conflicts.md#create-a-last-writer-wins-conflict-resolution-policy)
* [カスタム競合解決ポリシーを使用する方法](how-to-manage-conflicts.md#create-a-last-writer-wins-conflict-resolution-policy)
* [競合フィードを使用する方法](how-to-manage-conflicts.md#read-from-conflict-feed)
