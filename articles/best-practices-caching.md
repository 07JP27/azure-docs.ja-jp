<properties
   pageTitle="キャッシュに関するガイダンス | Microsoft Azure"
   description="キャッシュによるパフォーマンスとスケーラビリティの向上に関するガイダンス。"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# キャッシュに関するガイダンス

![](media/best-practices-caching/pnp-logo.png)

キャッシュは、頻繁にアクセスするデータをアプリケーションに近い場所に置かれた高速ストレージへと一時的にコピーすることで、システムのパフォーマンスとスケーラビリティを向上させるための一般的な手法です。この高速データ ストレージを元のソースよりもアプリケーションに近い場所に配置すると、キャッシュにより、データをより素早く供給してクライアント アプリケーションの応答時間を大幅に改善することができます。クライアント インスタンスが同じデータを繰り返して読み取る場合、特にデータが比較的に静的なままであり、かつ元のデータ ストアが、その速度がキャッシュに比べて遅いか、高レベルの競合の影響を受けるか、またはネットワーク レイテンシによりアクセス速度が低下するときに遠のく場合には、キャッシュは非常に有効です。

## 分散アプリケーションでのキャッシュ

データをキャッシュする場合、分散アプリケーションでは通常、次の戦略のどちらか、または両方を実装します。

- プライベート キャッシュを使用する (アプリケーションまたはサービスのインスタンスが実行されているコンピュータ上でデータがローカルに保持されている場合)。
- 共有キャッシュ (複数のプロセスやマシンがアクセス可能な共通ソースとして機能します) を使用する。

どちらの場合でも、キャッシュは、クライアント側 (Web ブラウザやデスクトップ アプリケーションなどのシステムのユーザー インターフェイスを提供するプロセスによって) とサーバ側 (リモートで実行されるビジネス サービスを提供するプロセスによって) のどちらでも実行できます。

### プライベート キャッシュ

最も基本的な種類のキャッシュは、単一のプロセスのアドレス空間に保持され、そのプロセスで実行されるコードによって直接アクセスされるメモリ内ストアです。この種類のキャッシュへのアクセスは非常に高速であり、キャッシュのサイズは通常、プロセスをホストするマシン上にある利用可能なメモリの量によって制限されるため、非常に効果的な少量の静的データの保存戦略を可能にします。メモリ内で物理的に可能な量よりも多くの情報をキャッシュする必要がある場合は、キャッシュされたデータをローカル ファイル システムに書き込むことができます。こうしたデータへのアクセスは、メモリ内に保持されたデータへのアクセスよりも必然的に遅くなりますが、ネットワーク経由でデータを取得するよりも早く、信頼性も高まります。

このモデルを使用するアプリケーションの複数のインスタンスを同時に実行する場合、各アプリケーション インスタンスは、それ自身のデータのコピーを保持する独立したキャッシュを持ちます。

キャッシュは、過去のある時点における元のデータのスナップショットであると考えてください。このデータが静的ではない場合、それぞれのアプリケーション インスタンスが、自身のキャッシュにある異なるバージョンのデータを保持する可能性があります。したがって、これらのインスタンスで同じクエリを実行しても、図 1 に示すように異なる結果が返される可能性があります。

![アプリケーションの複数のインスタンスにおけるメモリ内キャッシュの使用](media/best-practices-caching/Figure1.png)

_図 1: アプリケーションの複数のインスタンスにおけるメモリ内キャッシュの使用_

### 共有キャッシュ

共有キャッシュを使用すると、メモリ内キャッシュで起きる可能性があるような、キャッシュごとにデータが異なるかもしれないという不安を和らげることができます。共有キャッシュでは、図 2 に示すような別の場所 (通常は別のサービスの一部としてホストされます) にキャッシュを配置して、複数のアプリケーション インスタンスが同じ見た目のキャッシュされたデータを参照するようにします。

![共有キャッシュの使用](media/best-practices-caching/Figure2.png)

_図 2: 共有キャッシュの使用_

共有キャッシュを使用する方法の重要な利点は、この方法で提供できるスケーラビリティにあります。多くの共有キャッシュ サービスは、サーバーのクラスターを使用して実装され、クラスター全体にわたってデータを透過的に配布するソフトウェアを使用します。アプリケーションのインスタンスはキャッシュ サービスに要求を送信するだけであり、基になるインフラストラクチャが、クラスター内のキャッシュされたデータの場所の特定を担当します。サーバーの数を増やすことで、キャッシュを簡単に拡張できます。

共有キャッシュを用いる方法の欠点は、キャッシュが各アプリケーション インスタンスでローカルに保持されなくなるためにキャッシュへのアクセス速度が低下すること、および個別のキャッシュ サービスの実装要件によってソリューションの複雑さが増す可能性があることです。

## キャッシュの使用に関する注意点

次のセクションでは、キャッシュの設計と使用に関する注意点を詳細に説明します。

### データをキャッシュする必要がある時期

キャッシュによって、パフォーマンス、スケーラビリティ、および可用性が大幅に向上します。データの量が多いほど、またこのデータにアクセスする必要があるユーザーの数が多いほど、元のデータ ストア内で大量の同時要求の処理に関連した待機時間と競合を緩和することで、キャッシュを行うことの利点は大きくなります。たとえば、データベースがサポートしている同時接続数は制限されている可能性がありますが、現在利用可能な接続の数がなくなっている場合でも、基になるデータベースではなく共有キャッシュからデータを取得することで、クライアント アプリケーションはこのデータにアクセスすることができます。さらに、データベースを利用できなくなっても、クライアント アプリケーションはキャッシュに保持されているデータを使用して継続することができる可能性があります。

頻繁に読み取りが行われるが、変更はめったに行われないデータ (書き込み操作と比べて読み取り操作の割合が高いデータ) をキャッシュすることを検討してください。ただし、重要な情報に関する信頼できるストアとしてキャッシュを使用することはしないでください。アプリケーションが失うことが許されない変更内容はすべて、永続的なデータ ストアに常に保存する必要があります。こうすることで、キャッシュを使用できない場合でも、アプリケーションはこのデータ ストアを使用して処理を続行することができるため、重要な情報を失うことはありません。

### データとキャッシュの作成方法の種類

キャッシュを効果的に使用する鍵は、最もキャッシュに適したデータを決定し、適切なタイミングでそのデータをキャッシュすることにあります。アプリケーションがデータ ストアからデータを取得するのが 1 回で済み、それ以降のアクセスはキャッシュを使用して行うことができるように、データがアプリケーションによって初めて取得されたときに要求に応じてキャッシュにデータを追加します。

または、通常はアプリケーションの開始時に、前もってデータを部分的または完全にキャッシュに入力します (シード処理と呼ばれる方法です)。ただし、この方法では、アプリケーションの実行開始時に、元のデータ ストアに大きな負荷が急激にかかる可能性があるため、大きなキャッシュのシード処理は実装しないことをお勧めします。

多くの場合、使用パターンを分析することで、キャッシュの事前作成を完全にまたは部分的のどちらで行うのか決定し、キャッシュする必要のあるデータを選択しやすくなります。たとえば、アプリケーションを定期的 (たとえば毎日) に使用する顧客に関する静的なユーザー プロファイル データでキャッシュをシード処理することは有用ですが、1 週間に 1 度だけアプリケーションを使用する顧客のプロファイル データの場合は役には立たないでしょう。

通常、キャッシュは、変更することのできないデータまたは変更の頻度の低いデータでは十分に機能します。たとえば、e コマースアプリケーションの製品および価格情報などの参考情報や、構築するのに費用がかかる共有静的リソースなどです。こうしたデータの一部またはすべてをアプリケーションの起動時にキャッシュに読み込むことで、リソースに対する要求を最小限に抑えるとともに、パフォーマンスを向上させることができます。キャッシュ内の参照データを定期的に更新して最新に保つバックグラウンド プロセス、または参照データが変更されたときにキャッシュを更新するバックグラウンド プロセスを設定することが適切な場合もあります。

この注意点にはいくつかの例外がありますが、動的なデータではキャッシュはあまり有用ではありません (詳細については、このガイドの「非常に動的なデータのキャッシュ」セクションを参照してください)。元のデータが定期的に変更される場合、キャッシュされた情報がすぐに古くなるか、キャッシュを元のデータ ストアと同期させ続けるオーバーヘッドによってキャッシュの有効性が低下する可能性があります。キャッシュにはエンティティの完全なデータを含める必要はないことに注意してください。たとえば、あるデータ項目が、名前、住所、および口座残高を持つ銀行の顧客のような多値オブジェクトを表す場合、こうした要素の一部 (名前と住所) は静的なままですが、他の要素 (口座残高など) はより動的な場合があります。このような場合、データの静的な部分をキャッシュし、残りの情報は必要に応じて取得 (または計算) するだけにした方が有効な可能性があります。

キャッシュの事前入力またはオンデマンドの読み込み、あるいはその両方の組み合わせのどれが適しているかを判断するためには、パフォーマンスのテストと使用状況の分析を実行する必要があります。判断は、データの変化の頻度と使用パターンの組み合わせに基づいて行う必要があります。キャッシュの使用率とパフォーマンの分析は、大きな負荷がかかるため拡張性を高める必要のあるアプリケーションでは特に重要です。たとえば、拡張性の高いシナリオでは、キャッシュをシードしてピーク時にデータ ストアへの負荷を軽減することは有効です。

キャッシュを使用して、アプリケーションの実行時に計算が繰り返し行われることを防ぐこともできます。ある操作でデータの変換または複雑な計算を実行する場合、キャッシュ内に操作の結果を保存できます。後で同じ計算が必要になった場合、アプリケーションはキャッシュからその結果を取得するだけで済みます。

アプリケーションはキャッシュに保持されているデータを変更できますが、キャッシュは、いつでも消える可能性のある一時的なデータ ストアであると考えてください。重要なデータはキャッシュのみで保管せず、元のデータ ストアにも情報を保つようにしてください。これにより、キャッシュを使用できなくなった場合にデータを失う可能性が最小限に抑えられます。

### 非常に動的なデータのキャッシュ

急速に変化する情報を永続的なデータ ストアに保存すると、システムにオーバヘッドがかかる可能性があります。たとえば、状態などの測定値を継続的に報告するデバイスがあるとします。キャッシュされた情報がほとんどいつも期限切れであることを踏まえて、アプリケーションがこのデータをキャッシュしないことを選択した場合、この情報を保存およびデータ ストアから取得するときも同じ考察が行われます。このデータの保存および取得にかかる時間の間に、データが変更される可能性があるのです。このような状況では、動的な情報を永続的なデータ ストアではなく、キャッシュに直接保存するメリットを検討してください。データが重要なものではなく、監査する必要がない場合、不定期の変更内容が失われても問題にはなりません。

### キャッシュ内でのデータの有効期限の管理

ほとんどの場合は、キャッシュに保持されるデータは、元のデータ ストアに保持されているデータのコピーです。元のデータ ストアのデータがキャッシュ後に変更されると、キャッシュされたデータが古いものになります。多くのキャッシュ システムでは、キャッシュでデータの有効期限を設定して、データが期限切れになる期間を短縮することができます。

キャッシュされたデータは有効期限が切れるとキャッシュから削除され、アプリケーションは元のデータ ストアからそのデータを取得する必要があります (新しく取得した情報をキャッシュ内に戻すことができます)。キャッシュを設定するときに、既定の有効期限ポリシーを設定できます。多くのキャッシュ サービスでは、個々のオブジェクトをプログラムを使用してキャッシュ内に保存するときにその有効期限を指定することもできます (一部のキャッシュでは、絶対値として、または指定した期間内にアクセスされなかった場合にキャッシュからその項目を削除するスライド式の値として、有効期限を指定することができます)。この設定は、指定したオブジェクトについてのみ、任意のキャッシュ全体の有効期限ポリシーを上書きします。

> [AZURE.NOTE]キャッシュの有効期限とキャッシュに含まれるオブジェクトを慎重に検討してください。有効期限を短くしすぎると、オブジェクトはすぐに期限切れになり、キャッシュを使用するメリットが損なわれます。有効期限を長くしすぎると、データが古くなる危険性があります。

データが長期間にわたって常駐できるように設定されていると、キャッシュがいっぱいになる可能性もあります。この場合、キャッシュに新規項目を追加する要求により、削除と呼ばれるプロセスで、一部の項目が強制的に削除される可能性があります。キャッシュ サービスは、通常、最低使用頻度法 (LRU) に基づいてデータを削除しますが、一般にはこのポリシーを上書きして項目が削除されないようにすることができます。ただし、このアプローチを採用する場合は、キャッシュが使用可能なメモリを超え、キャッシュに項目を追加しようとしたアプリケーションが例外とともに失敗する危険性が生じます。

キャッシュの実装方法によっては、追加の削除ポリシーを使用できます。一般に、こうしたポリシーには、最高使用頻度ポリシー (データが再び必要になることはないと予想)、先入れ先出しポリシー (最も古いデータから削除)、またはトリガーされたイベント (データの変更など) に基づいた明示的な削除、などがあります。

### クライアント側キャッシュ内のデータの無効化

クライアント側のキャッシュに保持されているデータは、一般に、クライアントにデータを提供するサービスの保護下にはないとみなされます。サービスはクライアントに直接、クライアント側キャッシュの情報の追加または削除を強制的に実行させることはできません。つまり、十分に設定されていないキャッシュ (有効期限ポリシーが適切に設定されていないなど) を使用するクライアントが、元のデータ ソースの情報が変更された場合に、ローカルにキャッシュされた期限切れの情報を使用し続ける可能性があります。

HTTP 接続経由でデータを提供する Web アプリケーションを作成している場合、Web クライアント (ブラウザーまたは Web プロキシなど) に対して、リソースの URI を変更することでそのリソースが更新されたときに最新の情報を取得するように暗黙的に強制できます。Web クライアントは通常、クライアント側キャッシュのキーとしてリソースの URI を使用するため、URI を変更すると、Web クライアントは以前にキャッシュされたバージョンのリソースは無視して、代わりに新しいバージョンを取得します。

## キャッシュ内での同時実行の管理

多くの場合、キャッシュは、アプリケーションの複数のインスタンスで共有されるように設計されています。各アプリケーション インスタンスは、キャッシュ内のデータを読み取り、変更できます。このため、共有データ ストアで生じるものと同じ同時実行の問題が、キャッシュにも当てはまります。キャッシュ内に保持されているデータをアプリケーションが変更する必要がある状況では、アプリケーションの 1 つのインスタンスによって行われた更新が、他のインスタンスによって行われた変更を無条件に上書きしないようにする必要があります。

データの性質と競合が発生する可能性に応じて、2 つの同時実行制御方法のいずれかを採用することができます。

- __オプティミスティック同時実行制御。__ アプリケーションは、キャッシュ内のデータを更新する直前に、取得後にそのデータが変更されたかどうかを確認します。データが同じままの場合、変更できます。それ以外の場合、アプリケーションはこのデータを更新するかどうかを決定する必要があります (この決定の基準になるビジネス ロジックはアプリケーションごとに異なります)。この方法は、更新が頻繁に行われる状況、または競合が発生する可能性がない状況に適しています。
- __ペシミスティック同時実行制御。__ アプリケーションは、キャッシュ内のデータを取得するときにそのデータをロックして、他のインスタンスがそのデータを変更できないようにします。このプロセスによって競合は起きなくなりますが、同じデータを処理する必要がある他のインスタンスもブロックされる可能性があります。ペシミスティック同時実行制御は、ソリューションのスケーラビリティに影響をあたえる可能性があるため、一時的な操作にのみ使用するようにする必要があります。この方法は、競合が発生する可能性が高い状況、特にアプリケーションがキャッシュ内の複数の項目を更新するため、こうした変更が矛盾なく適用されるようにする必要がある場合に適しています。

### 高可用性とスケーラビリティの実装およびパフォーマンスの向上

キャッシュをデータのプライマリ リポジトリにすることはできません。この役割は、キャッシュの入力元である元のデータ ストアのものです。元のデータ ストアは、データの永続性を確保するために使用します。

ソリューションに、共有キャッシュ サービスの可用性に関する重要な依存関係が発生しないように注意してください。アプリケーションは、共有キャッシュを提供するサービスが使用できない場合も機能を継続できる必要があります。アプリケーションは、キャッシュ サービスの再開の待機中にハングまたは停止しないようにする必要があります。そのため、アプリケーションは、キャッシュ サービスの可用性を検出し、キャッシュにアクセスできない場合に元のデータ ストアにフォール バックするようにしておく必要があります。[サーキット ブレーカー パターン](http://msdn.microsoft.com/library/dn589784.aspx)が、このシナリオを処理するときに役立ちます。[キャッシュアサイド パターン](http://msdn.microsoft.com/library/dn589799.aspx)などの戦略に従うと、キャッシュキャッシュを提供するサービスを復元でき、サービスが使用可能になると、元のデータ ストアからデータを読み取るようにキャッシュに再入力することができます。

ただし、キャッシュが一時的に使用できない場合の元のデータ ストアへのフォール バックは、システムのスケーラビリティに影響を与える可能性があります。データ ストアの復元中に元のデータ ストアにデータの要求が押し寄せて、タイムアウトや接続の中断が起きる可能性があるのです。すべてのアプリケーション インスタンスがアクセスできる共有キャッシュとともに、アプリケーションの各インスタンスにローカルなプライベート キャッシュを実装する方法をお勧めします。アプリケーションは、項目を取得するときに、ローカル キャッシュ内、共有キャッシュ内、元のデータ ストア内の順に確認します。ローカル キャッシュは、共有キャッシュのデータを使用して、または共有キャッシュが使用できない場合はデータベースのデータを使用して設定できます。この方法では、ローカル キャッシュが共有キャッシュと比較して古くなりすぎないように注意深く設定する必要がありますが、ローカル キャッシュは共有キャッシュが到達可能でない場合にバッファーとして機能します。図 3 に、この構造を示します。

![共有キャッシュとローカルなプライベート キャッシュの併用](media/best-practices-caching/Caching3.png) _図 3: 共有キャッシュとローカルなプライベート キャッシュの併用_

一部のキャッシュ サービスでは、有効期間が比較的長いデータを保持する大規模なキャッシュをサポートするために、キャッシュが使用できなくなった場合に自動フェールオーバーを実装する、高可用性オプションを使用できます。通常、このアプローチでは、プライマリ キャッシュ サーバーに格納されているキャッシュされたデータをセカンダリ キャッシュ サーバーにレプリケートして、プライマリ サーバーで障害が発生するか接続が失われた場合にセカンダリ サーバーに切り替えます。複数の送信先への書き込みに伴う待機時間を短くするために、プライマリ サーバーのキャッシュにデータが書き込まれるときに、セカンダリ サーバーへのレプリケーションが非同期的に行われる場合があります。この方法では、障害発生時に一部のキャッシュされた情報が失われる可能性が生じますが、こうしたデータの割合はキャッシュのサイズ全体と比べると小さいと考えられます。

共有キャッシュのサイズが大きい場合、キャッシュされたデータを複数のノードに分割して、競合の可能性を抑えてスケーラビリティを高めることをお勧めします。多くの共有キャッシュでは、ノードを直接追加 (および削除) し、パーティション間でデータを再調整する機能がサポートされています。この方法ではクラスタリングが行われる場合があります。これによって、クライアント アプリケーションにはノードのコレクションが切れ目のない単一のキャッシュとして表示されますが、内部的には、負荷を均一に分散させるいくつかの定義済みの配布方法に従って、データがノード間に分散されます。Microsoft Web サイトの「[Data Partitioning Guidance](http://msdn.microsoft.com/library/dn589795.aspx)」(データのパーティション分割のガイダンス) ドキュメントでは、パーティション分割戦略に関する詳細が提供されています。

クラスタリングを行うことで、キャッシュの可用性もさらに高めることができます。ノードに障害が発生した場合でも、キャッシュの残りの部分には引き続きアクセスできます。クラスタリングは、多くの場合、レプリケーションとフェールオーバーを組み合わせて使用されます。各ノードをレプリケートして、ノードが故障した場合にそのレプリカを素早くオンラインにすることができます。

多くの読み取り操作および書き込み操作では、単一のデータの値またはオブジェクトが使用されます。ただし、大量のデータを迅速に保存または取得する必要がある場合があります。たとえば、キャッシュのシード処理では数百または数千個の項目をキャッシュに書き込む可能性があり、またアプリケーションが同じ要求の一部としてキャッシュから大量の関連項目を取得する必要があります。多くの大規模なキャッシュではこの目的のためのバッチ操作が提供されており、クライアント アプリケーションが大量の項目を 1 つの要求にまとめることができるようにして、小さな要求を大量に実行するときのオーバーヘッドを縮小できます。

## キャッシュおよび最終的な整合性

キャッシュアサイド パターンは、最新かつ一貫性のあるバージョンのデータにアクセスできるキャッシュを設定するアプリケーションのインスタンスに依存します。最終的な一貫性を実装するシステム (レプリケートされたデータ ストアなど) では、これに当てはまらない場合があります。アプリケーションの 1 つのインスタンスが、データ項目を変更し、その項目のキャッシュされたバージョンを無効化する可能性があります。アプリケーションの別のインスタンスはキャッシュからこの項目を読み取ろうとする場合がありますが、この試行はキャッシュミスの原因になります。このため、このインスタンスは、データをデータ ストアから読み取ってキャッシュに追加します。ただし、データ ストアが他のレプリカと完全には同期していない場合は、アプリケーション インスタンスは値が古いキャッシュを読み取り、設定する可能性があります。

データの一貫性の処理については、Microsoft Web サイトの「Data Consistency Guidance」(データの一貫性のガイダンス) ページを参照してください。

### キャッシュされたデータの保護

使用するキャッシュ サービスにかかわらず、キャッシュ内に保持されているデータを不正なアクセスから守る方法を検討する必要があります。次の 2 つの主な懸念事項があります。

- キャッシュ内のデータのプライバシー。
- キャッシュとキャッシュを使用するアプリケーションとの間を流れるデータのプライバシー。

キャッシュ サービスは、キャッシュ内のデータを保護するために、アプリケーションに自身の識別を必須とする認証メカニズム、およびキャッシュ内のデータにアクセス可能な ID と、これらの ID が実行できる操作 (読み取りと書き込み) を指定する認証スキームを実装する場合があります。データの読み取りおよび書き込みに伴うオーバーヘッドを抑えるために、ある ID にキャッシュへの書き込み/読み取りアクセス権が付与されると、その ID はキャッシュ内のデータを使用できるようになります。キャッシュされたデータのサブセットに対するアクセスを制限する場合は、次の操作を実行できます。

- (別のキャッシュ サーバーを使用して) キャッシュをパーティションに分割し、使用を許可するパーティションへのアクセス権のみを ID に付与する。
- 異なるキーを使用して各サブセット内のデータを暗号化し、各サブセットへのアクセス権を設定する必要がある ID にだけ暗号化キーを提供する。この場合、クライアント アプリケーションはキャッシュ内のすべてのデータを取得することができますが、キーを持っているデータの暗号化のみを解除することができます。

キャッシュに出入りするデータを保護するには、クライアント アプリケーションがキャッシュとの接続に使用するネットワーク インフラストラクチャで提供される、セキュリティ機能を使用する必要があります。クライアント アプリケーションをホストする同じ組織内のオンサイト サーバーを使用してキャッシュを実装する場合、ネットワークの隔離自体では追加の手順を行う必要はありません。キャッシュがリモートに配置され、パブリック ネットワーク (インターネットなど) 経由の TCP 接続または HTTP 接続が必要な場合、SSL の実装を検討する必要があります。

## Microsoft Azure でのキャッシュの実装に関する考慮事項

Azure は、Azure Redis Cache を提供します。これは、Azure データセンター内のサービスとして実行される Redis Cache というオープン ソースを実装したものです。Redis Cache は、Azure アプリケーションがクラウド サービスとして、Web サイトとして、または Azure 仮想マシン内に実装されているかにかかわらず、このアプリケーションからアクセスできるキャッシュ サービスを提供します。キャッシュは、適切なアクセス キーを持つクライアント アプリケーションで共有できます。

Redis は、可用性、スケーラビリティ、およびセキュリティを提供する高パフォーマンスのキャッシュ ソリューションです。通常、これは 1 台または複数台の専用マシン上に分散されたサービスとして実行され、メモリ内に可能な限り多くの情報を格納して、アクセスを高速化しようとします。このアーキテクチャは低速な I/O 操作を実行する必要性を減らすことで、待機時間の短縮とスループットの増加を実現するためのものです。

Azure Redis Cache には、クライアント アプリケーションで使用されるさまざまな API の多くとの互換性があります。オンプレミスで実行される Redis をすでに使用している既存のアプリケーションがある場合、Azure Redis Cache を使用して簡単にクラウド内のキャッシュへと移行することができます。

> [AZURE.NOTE]Azure では、Managed Cache Service も提供します。このサービスは、Microsoft AppFabric Cache エンジンに基づいています。このサービスを使用して、疎結合アプリケーションで共有できる分散キャッシュを作成することができます。キャッシュは、Azure データセンター内で実行されている高パフォーマンス サーバーでホストされます。ただし、このオプションは推奨されなくなりました。このオプションは、これを使用するように組み立てられた既存のアプリケーションをサポートするためだけに提供されています。新しく開発されたすべてのアプリケーションでは、代わりに Azure Redis Cache を使用します。
>
> さらに、Azure はロール内キャッシュをサポートします。この機能では、クラウド サービスに固有のキャッシュを作成することができます。キャッシュは Web ロールまたは worker ロールのインスタンスによってホストされ、同じクラウド サービス デプロイメント ユニットの一部として動作するロールのみがアクセスできます (デプロイメント ユニットは特定のリージョンにクラウド サービスとしてデプロイされたロール インスタンスの集合です)。キャッシュはクラスター化され、同じデプロイメント ユニット内でキャッシュをホストするロールのすべてのインスタンスは、同じキャッシュ クラスターの一部になります。ロール内キャッシュを使用する既存のアプリケーションではその使用を継続できますが、Azure Redis Cache への移行するとさらなるメリットが得られる可能性があります。Azure Redis Cache とロール内キャッシュのどちらを使用するべきかについては、Microsoft web サイトの「[どの Azure Cache を利用すればよいですか。](http://msdn.microsoft.com/library/azure/dn766201.aspx)」ページを参照してください


### Redis の機能

Redis は、単純なキャッシュ サーバーです。このドキュメントの後半にある「Redis キャッシュのユースケース」セクションで説明しているように、多くの一般的なシナリオをサポートする広範なコマンド セットを備えた分散型メモリ内データベースが提供されます。このセクションでは、Redis が提供するいくつかの重要な機能の概要を示します。

### メモリ内データベースとしての Redis

Redis は、読み取りと書き込みの両方をサポートします。(一時的なデータ ストアとみなす必要がある) 多くのキャッシュとは異なり、書き込み内容は、ローカルのスナップショット ファイルまたは追加専用のログ ファイルに定期的に保存することで、システムの故障から保護することができます。すべての書き込みは非同期であり、クライアントによるデータの読み取りと書き込みをブロックしません。Redis の実行を開始すると、スナップショットまたはログ ファイルからデータを読み取り、そのデータを使用してメモリ内キャッシュを構築します。詳細については、Redis Web サイトの「[Redis Persistence](http://redis.io/topics/persistence)」(Redis の永続性) を参照してください。

> [AZURE.NOTE]Redis では、重大な障害が発生したときにすべての書き込みが保存されることは保証されませんが、最悪の場合でも数秒間のデータを失うだけです。キャッシュは信頼できるデータ ソースとして機能するものではなく、重要なデータが適切なデータ ストアに正常に保存されるようにするのは、キャッシュを使用するアプリケーションの役割であることを忘れないでください。詳細については、「キャッシュアサイド パターン」を参照してください。

#### Redis データ型

Redis はキー値ストアであり、値には単純な型や、ハッシュ、リスト、およびセットなどの複雑なデータ構造を含めることができます。Redis は、このようなデータ型に対する一連のアトミック操作をサポートしています。キーは永続的なものにすることも、キーとその対応する値が自動的にキャッシュから削除される制限時間を指定することもできます。Redis のキーおよび値の詳細については、Redis Web サイトの「[An Introduction to Redis data types and abstractions](http://redis.io/topics/data-types-intro)」(Redis のデータ型と抽象化の概要) ページを参照してください。

#### Redis のレプリケーションとクラスタリング

Redis は、可用性を確保しつつスループットを維持するために、マスターと下位のレプリケーションをサポートしています。Redis マスター ノードへの書き込み操作は 1 つまたは複数の下位ノードにレプリケートされ、読み取り操作はマスター ノードまたはいずれかの下位ノードで処理することができます。ネットワーク パーティションが発生した場合、下位ノードはデータの処理を継続してから、接続が再度確立されたときにマスターと透過的に再同期することができます。詳細については、Redis Web サイトの「[Replication](http://redis.io/topics/replication)」(レプリケーション) ページを参照してください。

Redis ではクラスタリングも提供されるため、サーバー間のシャードにデータを透過的に分割して、負荷を分散することができます。この機能によって、キャッシュのサイズの増加に合わせて新しい Redis サーバーを追加し、データを再分割することができるため、スケーラビリティが向上します。さらに、マスターと下位のレプリケーションを使用し、クラスター内の各ノード間の可用性を確保して、クラスター内の各サーバーをレプリケートすることができます。クラスタリングとシャーディングの詳細については、Redis Web サイトの「[Redis Cluster Tutorial](http://redis.io/topics/cluster-tutorial)」(Redis クラスターのチュートリアル) ページを参照してください。

> [AZURE.NOTE]現在、Azure Redis Cache ではクラスタリングをサポートしていません。Redis クラスターを作成する場合は、独自のカスタム Redis サーバーを構築できます。詳細については、このドキュメントの後半の「カスタム Redis キャッシュの構築」セクションを参照してください。

### Redis のメモリ使用量

Redis キャッシュのサイズは、ホスト コンピューターで使用可能なリソースによって制限されます。Redis サーバーを構成するときに、使用できるメモリの最大量を指定できます。Redis キャッシュ内のキーには有効時間を設定することができ、この時間を過ぎるとキーがキャッシュから自動的に削除されます。この機能によって、古いまたは最新でなくなったデータでメモリ内キャッシュが埋め尽くされるのを防ぐことができます。

メモリが上限に達すると、Redis は多くのポリシーに従ってキーとその値を自動的に削除します。既定値は LRU (最も最近使用されていない) ですが、キーのランダムな削除や、削除をすべて無効化する (この場合、キャッシュがいっぱいになるとキャッシュに項目を追加する試行は失敗します) など、他のポリシーも選択することができます。詳細については、「[Using Redis as an LRU Cache](http://redis.io/topics/lru-cache)」(LRU キャッシュとしての Redis の使用) を参照してください。

### Redis のトランザクションとバッチ

Redis では、クライアント アプリケーションは、キャッシュ内のデータの読み取りおよび書き込みを行う一連の操作を、アトミック トランザクションとして送信することができます。トランザクション内のすべてのコマンドは必ず順番に実行され、他の同時実行クライアントにより発行されたコマンドがそれらに混ざることはありません。ただし、これらは正確にはトランザクションではなく、リレーショナル データベースが一連の操作を実行しています。トランザクション処理には、コマンド キューとコマンド実行の 2 つの段階があります。コマンド キューの段階では、トランザクションに含まれるコマンドがクライアントによって送信されます。この時点でなんらかのエラー (構文エラー、不正な数のパラメーターなど) が発生すると、Redis はトランザクション全体の処理を拒否して、廃棄します。実行フェーズでは、Redis はシーケンス内の各キューに登録されたコマンドを実行します。このフェーズでコマンドが失敗した場合、Redis は次のキューに登録されたコマンドの実行を継続しますが、すでに実行されたコマンドの影響をロール バックすることはありません。このように簡略化された形式のトランザクションにより、パフォーマンスを維持して、競合によって生じるパフォーマンスの問題を回避することができます。Redis は、一貫性の維持を支援するオプティミスティック同時実行制御の形式を実装しています。Redis を使用したトランザクションと同時実行制御の詳細については、Reids Web サイトの「[Transactions](http://redis.io/topics/transactions)」(トランザクション) ページを参照してください。

Redis では、要求の非トランザクション バッチ処理もサポートされています。Redis サーバーへのコマンドの送信にクライアントが使用する Redis プロトコルにより、クライアントは同じ要求の一部として一連の操作を送信することができます。これにより、ネットワーク上でのパケットの断片化を抑えることができます。バッチが処理されると、各コマンドが実行されます。トランザクションとは異なり、いずれかのコマンドの形式が不正である場合、それらは拒否されますが、残りのコマンドは実行されます。また、バッチ内のコマンドが処理される順番は保証されません。

### Redis のセキュリティ

Redis ではデータへの高速アクセスを実現することのみに重点が置かれており、信頼された環境内で実行され、信頼されたクライアントのみがアクセスするように設計されています。Redis では、パスワード認証に基づいた限定的なセキュリティ モデルだけがサポートされています (認証を完全に削除することもできますが、これは推奨されません)。すべての認証されたクライアントは同じグローバル パスワードを共有し、同じリソースにアクセスできます。より包括的なログイン セキュリティが必要な場合には、Redis サーバーの前に独自のセキュリティ層を実装し、すべてのクライアントの要求がこの追加した層を通過するようにする必要があります。Redis を、信頼されていないクライアントまたは認証されていないクライアントに直接公開しないでください。

コマンドを無効化するか、その名前を変更して (および特権のあるクライアントにだけ新しい名前を提供して)、コマンドへのアクセスを制限することができます。

Redis ではデータの暗号化形式は直接的にサポートされていないため、すべてのエンコードはクライアント アプリケーションが実行する必要があります。さらに、Redis ではトランスポート セキュリティが提供されないため、ネットワーク内を流れるデータを保護する必要がある場合には、SSL プロキシを実装する必要があります。

詳細については、Redis Web サイトの「[Redis Security](http://redis.io/topics/security)」(Redis のセキュリティ) ページを参照してください。

> [AZURE.NOTE]Azure Redis Cache は、クライアントが接続時に経由する独自のセキュリティ層を提供します。基になる Redis サーバーはパブリック ネットワークには公開されません。

### Azure Redis Cache の使用

Azure Redis Cache は、Azure データセンターでホストされたサーバーで実行されている Redis サーバーへのアクセスを提供し、アクセス制御とセキュリティを提供するファサードとして機能します。Microsoft Azure 管理ポータルを使用して、キャッシュをプロビジョニングすることができます。このポータルには、SSL 通信 (プライバシー用) と、99.9% の可用性を持つ SLA とのマスター/下位のレプリケーションをサポートする専用サービスとして実行される 53 GB キャッシュから、共有ハードウェア上で実行される、レプリケーションを持たない (可用性の保証がない) 250 MB キャッシュまで、数多くの定義済み設定があります。

Microsoft Azure 管理ポータルを使用する場合、キャッシュの削除ポリシーを設定したり、提供されるロール (所有者、共同作業者、閲覧者) にユーザーを追加することでキャッシュへのアクセスを制御したりすることができます。これらのロールは、メンバーが実行できる操作を定義します。たとえば、所有者ロールのメンバーは、キャッシュ (セキュリティを含む) とその内容を完全に制御することができ、共同作業者ロールのメンバーはキャッシュ内の情報の読み取りおよび書き込みを行うことができ、閲覧者ロールのメンバーはキャッシュからのデータの取得だけが可能です。

ほとんどの管理タスクは Microsoft Azure 管理ポータルから実行します。このため、プログラムを使用した設定の変更機能、Redis サーバーのシャットダウン機能、追加スレーブの設定機能、またはディスクへのデータの保存機能など、標準バージョンの Redis で使用可能な管理コマンドの多くは使用できません。

Microsoft Azure 管理ポータルには、キャッシュのパフォーマンスを監視できるようにする、便利なグラフィカル表示が含まれています。たとえば、確立されている接続の数、実行された要求の数、読み込みおよび書き込みの量、キャッシュ ミスに対するキャッシュ ヒットの数を確認できます。この情報を使用してキャッシュの有効性を判断し、必要に応じて、別の構成に切り替えるか、削除ポリシーを変更することができます。さらに、1 つ以上の重要な指標が想定される範囲を超えた場合に管理者に電子メール メッセージを送信する、アラートを作成することもできます。たとえば、過去 1 時間でキャッシュ ミスの数が指定された値を上回った場合、キャッシュが小さすぎるかデータの削除が早すぎるというアラートを、管理者に送ることができます。

CPU、メモリ、およびキャッシュのネットワーク使用率を監視することもできます。

> [AZURE.NOTE]Azure Redis Cache は、データベースではなく、単なるキャッシュとして機能するように設計されています。したがって、現在は Redis の永続性を実装していません。

詳細と Azure Redis Cache の作成および設定方法を示す例については、Azure ブログの「[Lap around Azure Redis Cache](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/)」(Azure Redis Cache に関する説明) ページを参照してください。

## セッション状態と HTML 出力のキャッシュ

Azure の Web ロールを使用して実行される ASP.NET Web アプリケーションを構築する場合、セッション状態の情報と HTML 出力を Azure Redis Cache 内に保存することができます。Azure Redis Cache 用のセッション状態プロバイダーを使用すると、ASP.NET Web アプリケーションの複数のインスタンス間でセッション情報を共有できます。これは、クライアント サーバーのアフィニティを使用できず、メモリ内のセッション データをキャッシュするのに適切でない Web ファームの状況で役立ちます。

セッション状態プロバイダーを Azure Redis Cache と併用すると、次のようないくつかのメリットが得られます。

- ASP.NET Web アプリケーションの多数のインスタンス間でセッション状態を共有できるので、スケーラビリティが向上します。
- 複数のリーダーと単一のライターによる、同じセッション状態データへの制御された同時アクセスをサポートします。
- 圧縮を使用してメモリを節約し、ネットワーク パフォーマンスを改善できます。

詳細については、Microsoft Web サイトの「[Azure Redis Cache 用の ASP.NET セッション状態プロバイダー](http://msdn.microsoft.com/library/azure/dn690522.aspx)」ページを参照してください。

> [AZURE.NOTE]Azure 環境の外で実行される ASP.NET アプリケーションには、Azure Redis Cache 用のセッション状態プロバイダーを使用しないでください。Azure の外部からのキャッシュへのアクセスで発生する待機時間によって、データをキャッシュするパフォーマンスの利点が失われる可能性があります。

同様に、Azure Redis Cache 用の出力キャッシュ プロバイダーを使用すると、ASP.NET Web アプリケーションによって生成される HTTP 応答を削減できます。出力キャッシュ プロバイダーと Azure Redis Cache を併用すると、複雑な HTML 出力を表示するアプリケーションの応答時間を改善することができます。似たような応答を生成するアプリケーション インスタンスは、このような HTML 出力を新たに生成するのではなく、キャッシュ内の共有出力フラグメントを活用できます。詳細については、Microsoft Web サイトの「[Azure Redis Cache 用の ASP.NET 出力キャッシュ プロバイダー](http://msdn.microsoft.com/library/azure/dn798898.aspx)」ページを参照してください

## カスタムの Redis キャッシュの構築

Azure Redis キャッシュは、基になる Redis サーバーに対するファサードとして機能します。現在は、構成の固定セットがサポートされていますが、Redis クラスタリング用の構成は提供されていません。Azure Redis Cache の対象ではない高度な構成 (53 GB を超えるキャッシュなど) が必要な場合は、Azure 仮想マシンを使用して独自の Redis サーバーを構築し、ホストできます。このプロセスは、レプリケーションを実装する場合にマスター ノードと下位ノードとして機能する複数の VM を作成する必要があるため、複雑になる可能性があります。さらに、クラスターを作成する場合は、複数のマスター サーバーと下位サーバーが必要になります。高度な可用性とスケーラビリティを実現する、最小限にクラスター化されたレプリケーション トポロジは、3 組のマスター/下位サーバーとして編成した少なくとも 6 台の VM で構成されます (1 つのクラスターには少なくとも 3 つのマスター ノードが必要です)。各マスター/下位の組は、待機時間を最小限に抑えるために近接して配置する必要があります。ただし、キャッシュされたデータを、そのデータを使用する可能性が最も高いアプリケーションの近くに配置する場合は、異なるリージョンに置かれた別々の Azure データセンターで各組のセットを実行することができます。Microsoft Web サイトの「[Running Redis on a CentOS Linux VM in Windows Azure](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)」(Windows Azure の CentOS Linux VM 上での Redis の実行) ページでは、Azure VM として実行される Redis ノードの構築および設定方法を示す例について説明しています。

この方法で独自の Redis キャッシュを実装する場合、サービスを監視、管理、および保護する責任があることに注意してください。

## Redis キャッシュのパーティション分割

キャッシュのパーティション分割では、複数のコンピューター間にキャッシュを分割します。この構造では、1 つのキャッシュ サーバーを使用することに比べて、次のような複数の利点があります。

- 1 つのサーバーに保存できるサイズよりもはるかに大きなキャッシュを作成できます。
- サーバー間でデータを配布することで、可用性を向上できます。1 つのサーバーで障害が発生するかアクセスできなくなった場合でも、使用できなくなるのはそのサーバーが保持しているデータだけであり、残りのサーバー上のデータにはアクセスできます。キャッシュにとってこれは重要なことではありません。キャッシュ データはデータベースに保持されているデータの一時的なコピーにすぎず、アクセスできなくなったサーバー上のキャッシュ データは代わりに別のサーバーにキャッシュできるからです。
- サーバー間で負荷を分散することで、パフォーマンスとスケーラビリティが向上します。
- 位置情報データを基にアクセスしたユーザーに近づき、待ち時間を短縮します。

キャッシュの最も一般的なパーティション分割の形態はシャーディングです。この方法では、各パーティション (シャード) はそれ自体の Redis キャッシュです。データは、シャーディング ロジックを使用して特定のパーティションに送られます。シャーディング ロジックではさまざまな方法を使用してデータを配布できます。「[Sharding Pattern](http://msdn.microsoft.com/library/dn589797.aspx)」(シャーディング パターン) で、シャーディングの実装について詳しく説明します。

Redis キャッシュでパーティション分割を実装するには、次の方法のいずれかを採用します。

- _サーバー側でクエリをルーティングする。_ この方法では、クライアント アプリケーションはキャッシュを構成する任意の Redis サーバー (ほとんどの場合は最も近いサーバー) に要求を送信します。各 Redis サーバーには、保持するパーティションを説明するメタデータが格納され、他のサーバーに配置されたパーティションに関する情報も含まれています。Redis サーバーがクライアントの要求を検証し、ローカルに解決できる場合は要求された操作を実行し、ローカルに解決できない場合は要求を適切なサーバーに転送します。このモデルは Redis クラスタリングによって実装されます。詳細は、Redis Web サイトの「[Redis cluster tutorial](http://redis.io/topics/cluster-tutorial)」(Redis クラスターのチュートリアル) ページに記載されています。Redis クラスタリングはクライアント アプリケーションにとって透過的なものであり、クライアントを再構成しなくても追加の Redis サーバーをクラスター (および再パーティション分割されたデータ) に追加できます。

  >[AZURE.IMPORTANT]現在、Azure Redis Cache では Redis クラスタリングをサポートしていません。この方法を実装する場合は、カスタムの Redis キャッシュを前述の方法で作成してください。

- _クライアント側でパーティション分割する。_ このモデルでは、要求を適切な Redis サーバーにルーティングするロジックは (ほとんどの場合はライブラリの形態で)、クライアント アプリケーションに含まれます。この方法は Azure Redis Cache で使用できます。複数の Azure Redis Cache を (データ パーティションごとに 1 つ) 作成し、要求を適切なキャッシュにルーティングするクライアント側ロジックを実装します。パーティション分割の設定を変更する場合 (追加の Azure Redis Cache を作成するなど) は、クライアント アプリケーションの再構成が必要になることがあります。

- _プロキシでパーティション分割する。_ この設定では、クライアント アプリケーションは、データのパーティション分割方法を理解し適切な Redis サーバーに要求をルーティングする中間プロキシ サービスに要求を送信します。この方法も Azure Redis Cache で使用できます。プロキシ サービスは、Azure クラウド サービスとして実装することができます。この方法では複雑さのレベルを追加してサービスを実装する必要があり、クライアント側でのパーティション分割よりも要求の実行に時間がかかる場合があります。

Redis Web サイトの「[Partitioning: how to split data among multiple Redis instances ](http://redis.io/topics/partitioning)」(パーティション分割: 複数の Redis インスタンス間でデータを分割する方法) ページに、Redis へのパーティション分割の実装に関する詳細情報が記載されています。

### Redis キャッシュ クライアント アプリケーションの実装

Redis は、さまざまなプログラミング言語で記述されたクライアント アプリケーションをサポートします。.NET Framework を使用して新しいアプリケーションを作成する場合は、StackExchange.Redis クライアント ライブラリを使用する方法をお勧めします。このライブラリは Redis サーバーへの接続、コマンドの送信、および応答の受信の詳細を抽象化する .NET Framework のオブジェクト モデルを提供します。このライブラリは NuGet パッケージとして Visual Studio で入手できます。この同じライブラリを使用すると、Azure Redis Cache または VM でホストされているカスタムの Redis キャッシュに接続することができます。

Redis サーバーに接続するには、`ConnectionMultiplexer` クラスの静的な `Connect` メソッドを使用します。このメソッドで作成される接続は、クライアント アプリケーションの有効期間を通して使用するように設計されているため、複数の同時実行スレッドで同じ接続を使用できます。パフォーマンスが低下する可能性があるので、Redis 操作を実行するたびに再接続/切断しないでください。Redis ホストのアドレスやパスワードなどの接続パラメーターを指定できます。Azure Redis Cache を使用している場合、このパスワードは、Microsoft Azure 管理ポータルを使用して Azure Redis Cache 用に生成されたプライマリまたはセカンダリ キーになります。

Redis サーバーに接続すると、キャッシュとして機能する Redis データベースを操作できます。Redis 接続では、これを行う `GetDatabase` メソッドが提供されます。キャッシュから項目を取得したりキャッシュにデータを格納したりするには、`StringGet` メソッドと `StringSet` メソッドを使用します。これらのメソッドにはパラメーターとしてキーを指定する必要があります。一致する値を持つキャッシュ内の項目 (`StringGet`) が返されるか、このキーを持つキャッシュに項目が追加されます (`StringSet`)。

Redis サーバーの場所によっては、多くの操作で、要求がサーバーに転送され応答がクライアントに返されるまでの待機時間が発生する可能性があります。StackExchange ライブラリには、クライアント アプリケーションの応答性を保つために公開されている、非同期バージョンのメソッドが多数あります。これらのメソッドは、.NET Framework の[タスクベースの非同期パターン](http://msdn.microsoft.com/library/hh873175.aspx)をサポートします。

次のコード スニペットに示す `RetrieveItem` という名前のメソッドは、Redis と StackExchange ライブラリをベースにしたキャッシュアサイド パターンの実装例です。このメソッドは、文字列のキー値を取り、`StringGetAsync` メソッド (非同期バージョンの `StringGet`) を呼び出すことによって Redis キャッシュから対応する項目を取得しようとします。項目が見つからない場合は、`GetItemFromDataSourceAsync` メソッド (ローカル メソッドであり StackExchange ライブラリには含まれません) を使用してベースとなっているデータ ソースから項目を取得し、`StringSetAsync` メソッドを使用してキャッシュに追加することで、次回からより迅速に取得できるようにします。

```csharp
// Connect to the Azure Redis cache
ConfigurationOptions config = new ConfigurationOptions();
config.EndPoints.Add("<your DNS name>.redis.cache.windows.net");
config.Password = "<Redis cache key from management portal>";
ConnectionMultiplexer redisHostConnection = ConnectionMultiplexer.Connect(config);
IDatabase cache = redisHostConnection.GetDatabase();
...
private async Task<string> RetrieveItem(string itemKey)
{
    // Attempt to retrieve the item from the Redis cache
    string itemValue = await cache.StringGetAsync(itemKey);

    // If the value returned is null, the item was not found in the cache
    // So retrieve the item from the data source and add it to the cache
    if (itemValue == null)
    {
        itemValue = await GetItemFromDataSourceAsync(itemKey);
        await cache.StringSetAsync(itemKey, itemValue);
    }

    // Return the item
    return itemValue;
}
```

`StringGet` と `StringSet` は、文字列値の取得と格納のためだけのメソッドではありません。バイトの配列としてシリアル化された任意の項目を取ることができます。.NET オブジェクトを保存する必要がある場合は、バイト ストリームとしてシリアル化し、StringSet メソッドを使用してキャッシュに書き込むことができます。同様に、StringGet メソッドを使用してキャッシュからオブジェクトを読み取り、.NET オブジェクトとして逆シリアル化できます。次のコードに、IDatabase インターフェイスの一連の拡張メソッド (Redis 接続の GetDatabase メソッドは `IDatabase` オブジェクトを返します) と、これらのメソッドを使用して BlogPost オブジェクトを読み取りキャッシュに書き込むサンプル コードを示します。

```csharp
public static class RedisCacheExtensions
{
    public static async Task<T> GetAsync<T>(this IDatabase cache, string key)
    {
        return Deserialize<T>(await cache.StringGetAsync(key));
    }

    public static async Task<object> GetAsync(this IDatabase cache, string key)
    {
        return Deserialize<object>(await cache.StringGetAsync(key));
    }

    public static async Task SetAsync(this IDatabase cache, string key, object value)
    {
        await cache.StringSetAsync(key, Serialize(value));
    }

    static byte[] Serialize(object o)
    {
        byte[] objectDataAsStream = null;

        if (o != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream())
            {
                binaryFormatter.Serialize(memoryStream, o);
                objectDataAsStream = memoryStream.ToArray();
            }
        }

        return objectDataAsStream;
    }

    static T Deserialize<T>(byte[] stream)
    {
        T result = default(T);

        if (stream != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream(stream))
            {
                result = (T)binaryFormatter.Deserialize(memoryStream);
            }
        }

        return result;
    }
}
```

次のコードに示す `RetrieveBlogPost` という名前のメソッドは、これらの拡張メソッドを使用してシリアル化可能な `BlogPost` オブジェクトを読み取り、キャッシュアサイド パターンに従ってキャッシュに書き込みます。

```csharp
// The BlogPost type
[Serializable]
private class BlogPost
{
    private HashSet<string> tags = new HashSet<string>();

    public BlogPost(int id, string title, int score, IEnumerable<string> tags)
    {
        this.Id = id;
        this.Title = title;
        this.Score = score;
        this.tags = new HashSet<string>(tags);
    }

    public int Id { get; set; }
    public string Title { get; set; }
    public int Score { get; set; }
    public ICollection<string> Tags { get { return this.tags; } }
}
...
private async Task<BlogPost> RetrieveBlogPost(string blogPostKey)
{
    BlogPost blogPost = await cache.GetAsync<BlogPost>(blogPostKey);
    if (blogPost == null)
    {
        blogPost = await GetBlogPostFromDataSourceAsync(blogPostKey);
        await cache.SetAsync(blogPostKey, blogPost);
    }

    return blogPost;
}
```

Redis は、クライアント アプリケーションが複数の非同期要求を送信する場合のコマンド パイプライン処理をサポートします。Redis は、厳密な順序でコマンドを受信して応答するのではなく、同じ接続を使用して要求を多重化できます。この方法では、ネットワークの使用効率を高めて待機時間を短縮できます。次のコード スニペットに、同時に 2 人の顧客の詳細を取得する例を示します。このコードは、2 つの要求を送信後、結果の受信を待機する前に他の処理 (ここでは示されていません) を実行します。キャッシュ オブジェクトの Wait メソッドは、.NET Framework の Task.Wait メソッドに似ています。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
var task1 = cache.StringGetAsync("customer:1");
var task2 = cache.StringGetAsync("customer:2");
...
var customer1 = cache.Wait(task1);
var customer2 = cache.Wait(task2);
```

Microsoft Web サイトの「[Azure Redis キャッシュ (プレビュー) の開発](http://msdn.microsoft.com/library/azure/dn690520.aspx)」ページに、Azure Redis Cache を使用できるクライアント アプリケーションを作成する方法の詳細が記載されています。その他の情報は、StackExchange.Redis の Web サイトの「[Basic Usage](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)」(基本的な使用法) ページで確認できます。この Web サイトの「[Pipelines and Multiplexers](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)」(パイプラインとマルチプレクサー) ページには、Redis と StackExchange ライブラリを使用する非同期操作とパイプライン処理の詳細も記載されています。このガイダンス後半の「Redis キャッシュのユースケース」セクションで、Redis キャッシュに保持されているデータに適用できる、より高度な手法の例をいくつか示します。

## Redis キャッシュのユースケース

キャッシュに Redis を使用する最も簡単な例では、キー/値のペアの格納を考えます。ここでは、値は解釈されていない任意の長さの文字列で、バイナリ データ (基本的には文字列として処理できるバイトの配列) が含まれることがあります。このシナリオは、このガイダンス前半の「Redis キャッシュ クライアント アプリケーションの実装」セクションで説明しました。解釈されていないデータはキーにも含まれるため、任意のバイナリ情報をキーとして使用できます。ただし、キーが長くなればなるほど格納に必要な領域は大きくなり、参照操作の実行時間も長くなることに注意する必要があります。使いやすさと保守のしやすさを考慮して、キースペースは慎重に設計し、意味のある (しかし冗長ではない) キーを使用してください。たとえば ID が 100 の顧客のキーを表す場合は、単純に “100” とするのではなく、“customer:100” のような構造化されたキーを使用します。このような設定にすると、さまざまなデータ型を格納する複数の値を簡単に区別することができます。たとえば ID が 100 の注文のキーを表すために、キー “orders:100” を使用することもできます。

Redis のキー/値のペアの値には、1 次元のバイナリ文字列以外にも、リスト、セット (並べ替えあり、並べ替えなし)、ハッシュなどのより構造化された情報も格納できます。Redis には、これらの型を操作できる包括的なコマンド セットが用意されています。これらのコマンドの多くは StackExchange などのクライアント ライブラリを介して .NET Framework アプリケーションで使用できます。Redis Web サイトの「[An introduction to Redis data types and abstractions](http://redis.io/topics/data-types-intro)」(Redis のデータ型と抽象化の概要) ページに、これらの型と操作に使用できるコマンドのより詳細な概要が記載されています。

このセクションでは、これらのデータ型とコマンドの一般的なユースケースをいくつか示します。

### アトミック操作とバッチ操作の実行

Redis は、文字列値を取得および設定する一連のアトミック操作をサポートします。これらの操作では、`GET` コマンドと `SET` コマンドを個別に使用するときに発生する可能性のある競合状態によるハザードを排除します。次のような操作を実行できます。

- `INCR`、`INCRBY`、`DECR`、および `DECRBY` は、整数データ値をインクリメントおよびデクリメントするアトミック操作を実行します。StackExchange ライブラリには、これらの操作を実行し、キャッシュに格納された結果の値を返すオーバーロード バージョンの `IDatabase.StringIncrementAsync` メソッドと `IDatabase.StringDecrementAsync` メソッドがあります。次のコード スニペットに、これらのメソッドを使用する方法を示します。

  ```csharp ConnectionMultiplexer redisHostConnection = ...; IDatabase cache = redisHostConnection.GetDatabase(); ... await cache.StringSetAsync("data:counter", 99); ... long oldValue = await cache.StringIncrementAsync("data:counter"); // 1 ずつインクリメント (既定) // oldValue は 100 になるはずです

  long newValue = await cache.StringDecrementAsync("data:counter", 50); // 50 ずつデクリメント// newValue は 50 になるはずです```

- `GETSET` は、キーに関連付けられている値を取得し、新しい値に変更します。StackExchange ライブラリでは、この操作を `IDatabase.StringGetSetAsync` メソッドで実行できます。以下のコード スニペットに、このメソッドの例を示します。このコードは、同じ操作の一部として、上の例の “data:counter” キーに関連付けられている現在の値を返し、このキーの値をゼロにリセットします。

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  string oldValue = await cache.StringGetSetAsync("data:counter", 0);
  ```

- `MGET` と `MSET` は、単一の操作として、一連の文字列値を返すか変更します。`IDatabase.StringGetAsync` メソッドと `IDatabase.StringSetAsync` メソッドは、次の例のように、この機能をサポートするためにオーバーロードされます。

  ```csharp ConnectionMultiplexer redisHostConnection = ...; IDatabase cache = redisHostConnection.GetDatabase(); ... // キー/値ペアのリストを作成 var keysAndValues = new List<KeyValuePair<RedisKey  RedisValue>>() { new KeyValuePair<RedisKey  RedisValue>("data:key1", "value1"), new KeyValuePair<RedisKey  RedisValue>("data:key99", "value2"), new KeyValuePair<RedisKey  RedisValue>("data:key322", "value3") };

  // キー/値ペアのリストをキャッシュに格納 cache.StringSet(keysAndValues.ToArray()); ... // キーのリストに一致するすべての値を検索 RedisKey keys = { "data:key1", "data:key99", "data:key322"}; RedisValue values = null; values = cache.StringGet(keys); // values には { "value1", "value2", "value3" } が含まれるはずです```

このガイダンスの「Redis のトランザクションとバッチ」セクションで説明されているように、複数の操作を組み合わせて 1 つの Redis トランザクションにすることもできます。StackExchange ライブラリは、`ITransaction` インターフェイスを介してトランザクションをサポートします。IDatabase.CreateTransaction メソッドを使用することで ITransaction オブジェクトを作成し、`ITransaction` オブジェクトが提供するメソッドを使用することでトランザクションに対してコマンドを呼び出すことができます。`ITransaction` インターフェイスでは、`IDatabase` インターフェイスと同様の一連のメソッドを使用できますが、すべてのメソッドが非同期である点が異なります。これらのメソッドは、`ITransaction.Execute` メソッドが呼び出されたときにのみ実行されます。Execute メソッドから返される値は、トランザクションが正常に作成されたか (true) 作成に失敗したか (false) を示します。

次のコード スニペットに、同じトランザクションの中で 2 つのカウンターをインクリメントおよびデクリメントする例を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
ITransaction transaction = cache.CreateTransaction();
var tx1 = transaction.StringIncrementAsync("data:counter1");
var tx2 = transaction.StringDecrementAsync("data:counter2");
bool result = transaction.Execute();
Console.WriteLine("Transaction {0}", result ? "succeeded" : "failed");
Console.WriteLine("Result of increment: {0}", tx1.Result);
Console.WriteLine("Result of decrement: {0}", tx2.Result);
```

Redis トランザクションはリレーショナル データベースのトランザクションとは異なることに注意してください。Execute メソッドは、実行するトランザクションを構成するすべてのコマンドをキューに登録するだけです。コマンドのいずれかの形式が正しくない場合は、トランザクションは中止されます。すべてのコマンドが正常にキューに登録されると、各コマンドは非同期的に実行されます。いずれかのコマンドが失敗した場合にも、他のコマンドは継続して処理されます。コマンドが正常に完了したことを確認する必要がある場合は、上の例に示すように、対応するタスクの Result プロパティを使用してコマンドの結果を取得する必要があります。Result プロパティの読み取りは、タスクが完了するまでブロックされます。

詳細については、StackExchange.Redis の Web サイトの「[Transactions in Redis](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)」(Redis のトランザクション) に関するページを参照してください。

バッチ操作を実行するには、StackExchange ライブラリの IBatch インターフェイスを使用します。このインターフェイスでは、IDatabase インターフェイスと同様の一連のメソッドにアクセスできますが、すべてのメソッドが非同期である点が異なります。次の例に示すように、IDatabase.CreateBatch メソッドを使用して IBatch オブジェクトを作成し、次に IBatch.Execute メソッドを使用してバッチを実行します。このコードでは、単純に文字列値を設定し、前の例で使用したのと同じカウンターをインクリメントおよびデクリメントして結果を表示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
IBatch batch = cache.CreateBatch();
batch.StringSetAsync("data:key1", 11);
var t1 = batch.StringIncrementAsync("data:counter1");
var t2 = batch.StringDecrementAsync("data:counter2");
batch.Execute();
Console.WriteLine("{0}", t1.Result);
Console.WriteLine("{0}", t2.Result);
```

トランザクションとは異なり、バッチ内のコマンドの形式が正しくないために失敗した場合も他のコマンドは実行できると理解することが重要です。IBatch.Execute メソッドは、成功または失敗を示す結果を一切返しません。

### ファイア アンド フォーゲット キャッシュ操作の実行

Redis は、コマンドのフラグを使用することでファイア アンド フォーゲット操作をサポートします。この場合は、クライアントは操作を開始するだけで、結果は考慮せず、コマンドの完了も待機しません。以下の例に、ファイア アンド フォーゲット操作として INCR コマンドを実行する方法を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
await cache.StringSetAsync("data:key1", 99);
...
cache.StringIncrement("data:key1", flags: CommandFlags.FireAndForget);
```

### 自動的に期限切れになるキー

Redis キャッシュに項目を格納するときに、項目をキャッシュから自動的に削除するまでのタイムアウトを指定できます。`TTL` コマンドを使用すると、キーが期限切れになるまでに残されている時間をクエリすることもできます。このコマンドを StackExchange アプリケーションで使用するには、IDatabase.KeyTimeToLive メソッドを使用します。

次のコード スニペットに、キーに 20 秒の有効期限を設定して、キーの残り時間をクエリする例を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration time of 20 seconds
await cache.StringSetAsync("data:key1", 99, TimeSpan.FromSeconds(20));
...
// Query how much time a key has left to live
// If the key has already expired, the KeyTimeToLive function returns a null
TimeSpan? expiry = cache.KeyTimeToLive("data:key1");
```

EXPIRE コマンドを使用すると有効期限を特定の日時に設定することもできます。このコマンドは、StackExchange ライブラリでは KeyExpireAsync メソッドとして使用できます。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration date of midnight on 1st January 2015
await cache.StringSetAsync("data:key1", 99);
await cache.KeyExpireAsync("data:key1",
    new DateTime(2015, 1, 1, 0, 0, 0, DateTimeKind.Utc));
...
```

> _ヒント:_ 項目をキャッシュから手動で削除するには DEL コマンドを使用します。このコマンドは、StackExchange ライブラリでは IDatabase.KeyDeleteAsync メソッドとして使用できます。

### タグを使用するキャッシュされた項目のクロス関連付け

Redis セットは、1 つのキーを共有する複数の項目のコレクションです。セットを作成するには、SADD コマンドを使用します。セット内の項目は、SMEMBERS コマンドを使用して取得できます。StackExchange ライブラリでは、SADD コマンドはIDatabase.SetMembersAsync メソッド、SMEMBERS コマンドは IDatabase.SetAddAsync メソッドを介して実装されています。SDIFF (差集合) コマンド、SINTER (積集合) コマンド、および SUNION (和集合) コマンドを使用して、既存のセットを組み合わせて新しいセットを作成することもできます。StackExchange ライブラリでは、これらの操作は IDatabase.SetCombineAsync メソッドにまとめられています。このメソッドの最初のパラメーターでは、実行するセット操作を指定します。

次のコード スニペットに、関連する項目のコレクションをすばやく格納したり取得したりするのにセットがどれほど威力を発揮するかを示します。このコードでは、「Redis キャッシュ クライアント アプリケーションの実装」セクションで説明した BlogPost 型を使用します。BlogPost オブジェクトには 4 つのフィールド (ID、タイトル、順位付けスコア、タグのコレクション) が含まれています。以下の最初のコード スニペットに、BlogPost オブジェクトの C# コードのリストを設定するために使用するサンプル データを示します。

```csharp
List<string[]> tags = new List<string[]>()
{
    new string[] { "iot","csharp" },
    new string[] { "iot","azure","csharp" },
    new string[] { "csharp","git","big data" },
    new string[] { "iot","git","database" },
    new string[] { "database","git" },
    new string[] { "csharp","database" },
    new string[] { "iot" },
    new string[] { "iot","database","git" },
    new string[] { "azure","database","big data","git","csharp" },
    new string[] { "azure" }
};

List<BlogPost> posts = new List<BlogPost>();
int blogKey = 0;
int blogPostId = 0;
int numberOfPosts = 20;
Random random = new Random();
for (int i = 0; i < numberOfPosts; i++)
{
    blogPostId = blogKey++;
    posts.Add(new BlogPost(
        blogPostId,               // Blog post ID
        string.Format(CultureInfo.InvariantCulture, "Blog Post #{0}",
            blogPostId),          // Blog post title
        random.Next(100, 10000),  // Ranking score
        tags[i % tags.Count]));   // Tags – assigned from a collection
                                  // in the tags list
}
```

各 BlogPost オブジェクトのタグをセットとして Redis キャッシュに格納し、各セットに BlogPost の ID を関連付けることができます。これにより、特定のブログの投稿に属するすべてのタグをアプリケーションですばやく検索できます。逆引き検索を有効にして、特定のタグを共有するすべてのブログの投稿を検索するには、キーに含まれるタグ ID を参照するブログの投稿を保持する別のセットを作成します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Tags are easily represented as Redis Sets
foreach (BlogPost post in posts)
{
    string redisKey = string.Format(CultureInfo.InvariantCulture,
        "blog:posts:{0}:tags", post.Id);
    // Add tags to the blog post in redis
    await cache.SetAddAsync(
        redisKey, post.Tags.Select(s => (RedisValue)s).ToArray());

    // Now do the inverse so we can figure how which blog posts have a given tag.
    foreach (var tag in post.Tags)
    {
        await cache.SetAddAsync(string.Format(CultureInfo.InvariantCulture,
            "tag:{0}:blog:posts", tag), post.Id);
    }
}
```

これらの構造によって、多くの一般的なクエリを非常に効率よく実行することができます。たとえば、次のようにすると、ブログの投稿 1 のすべてのタグを検索して表示できます。

```csharp
// Show the tags for blog post #1
foreach (var value in await cache.SetMembersAsync("blog:posts:1:tags"))
{
    Console.WriteLine(value);
}
```

次のような積集合演算を実行することで、ブログの投稿 1 とブログの投稿 2 に共通するすべてのタグを検索できます。

```csharp
// Show the tags in common for blog posts #1 and #2
foreach (var value in await cache.SetCombineAsync(SetOperation.Intersect, new RedisKey[]
    { "blog:posts:1:tags", "blog:posts:2:tags" }))
{
    Console.WriteLine(value);
}
```

また、次のようにすると、特定のタグを含むすべてのブログの投稿を検索できます。

```csharp
// Show the ids of the blog posts that have the tag "iot".
foreach (var value in await cache.SetMembersAsync("tag:iot:blog:posts"))
{
    Console.WriteLine(value);
}
```

### 最近アクセスした項目の検索

多くのアプリケーションに伴う共通の問題に、最近アクセスした項目の検索があります。たとえば、あるブログ サイトで最近読まれたブログの投稿を表示する必要があるとしましょう。この機能を実装するには、Redis リストを使用します。Redis リストには、同じキーを共有する複数の項目が含まれていますが、このリストは両端キューとして機能します。LPUSH (左プッシュ) コマンドと RPUSH (右プッシュ) コマンドを使用すると、リストのどちら側の終端にも項目をプッシュできます。LPOP コマンドと RPOP コマンドを使用すると、リストのどちら側の終端からも項目を取得できます。LRANGE コマンドと RRANGE コマンドを使用すると、要素のセットを返すこともできます。以下のコード スニペットに、StackExchange ライブラリを使用してこれらの操作を実行する方法を示します。このコードでは、これまでの例の BlogPost 型を使用します。ブログの投稿がユーザーに読まれると、IDatabase.ListLeftPushAsync メソッドを使用して、ブログの投稿のタイトルが Redis キャッシュの "blog:recent\_posts" キーに関連付けられているリストにプッシュされます。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:recent_posts";
BlogPost blogPost = ...; // reference to the blog post that has just been read
await cache.ListLeftPushAsync(
    redisKey, blogPost.Title); // push the blog post onto the list
```

さらに別のブログ投稿が読まれたときにも、それらのタイトルは同じリストにプッシュされます。リストは、タイトルが追加された順になります。最近読まれたブログの投稿がリストの左端に向かって並びます。(同じブログの投稿が複数回読まれた場合は、リストに複数のエントリが含まれることになります)。IDatabase.ListRange メソッドを使用すると、最近読まれた投稿のタイトルを表示できます。このメソッドは、リスト、開始位置、および終了位置を含むキーを取ります。次のコードでは、リストの左端から 10 個のブログの投稿 (0 ～ 9 の項目) のタイトルを取得します。

```csharp
// Show latest ten posts
foreach (string postTitle in await cache.ListRangeAsync(redisKey, 0, 9))
{
    Console.WriteLine(postTitle);
}
```

ListRangeAsync はリストから項目を削除しないことに注意してください。削除するには、IDatabase.ListLeftPopAsync メソッドや IDatabase.ListRightPopAsync メソッドを使用します。

リストが無制限に大きくなるのを回避するには、定期的にリストをトリミングすることで項目の数を減らします。以下のコード スニペットでは、左端の 5 項目以外のすべての項目をリストから削除します。

```csharp
await cache.ListTrimAsync(redisKey, 0, 5);
```

### スコア ボードの実装

既定では、セット内の項目は特定の順序で保持されません。ZADD コマンド (StackExchange ライブラリの IDatabase.SortedSetAdd メソッド) を使用すると、順序付けされたセットを作成することができます。項目は、コマンドのパラメーターとして指定する、スコアと呼ばれる数値を使用して並べます。次のコード スニペットでは、ブログの投稿のタイトルを順序付きリストに追加します。この例では、各ブログの投稿にもブログの投稿の順位を含むスコア フィールドが設定されています。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:post_rankings";
BlogPost blogPost = ...; // reference to a blog post that has just been rated
await cache.SortedSetAddAsync(redisKey, blogPost.Title, blogpost.Score);
```

IDatabase.SortedSetRangeByRankWithScores メソッドを使用すると、ブログの投稿のタイトルとスコアを昇順で取得できます。

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(redisKey))
{
    Console.WriteLine(post);
}
```

> [AZURE.NOTE]StackExchange ライブラリには、スコアの順序でデータを返す IDatabase.SortedSetRangeByRankAsync メソッドもあります。ただしこのメソッドは、スコアは返しません。

IDatabase.SortedSetRangeByRankWithScoresAsync メソッドに追加のパラメーターを指定することで、スコアの降順でも項目を取得でき、返される項目の数を制限することもできます。次の例では、上位 10 個のブログの投稿のタイトルとスコアを表示します。

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(
                               redisKey, 0, 9, Order.Descending))
{
    Console.WriteLine(post);
}
```

次の例では、返される項目数を指定したスコア範囲におさまる項目数に制限できる IDatabase.SortedSetRangeByScoreWithScoresAsync メソッドを使用します。

```csharp
// Blog posts with scores between 5000 and 100000
foreach (var post in await cache.SortedSetRangeByScoreWithScoresAsync(
                               redisKey, 5000, 100000))
{
    Console.WriteLine(post);
}
```

### チャネルを使用したメッセージング

Redis サーバーは、データ キャッシュとして機能する以外にも、高パフォーマンスのパブリッシャー/サブスクライバー メカニズムを使用してメッセージング機能を提供します。クライアント アプリケーションはチャネルにサブスクライブし、他のアプリケーションまたはサービスはチャネルにメッセージを発行できます。サブスクライブしているアプリケーションは、これらのメッセージを受信し、処理することができます。

Redis は、チャネルにサブスクライブするための SUBSCRIBE コマンドを提供します。このコマンドでは、アプリケーションがメッセージを受け入れるチャネルの名前を 1 つまたは複数指定する必要があります。StackExchange ライブラリには ISubscription インターフェイスが含まれ、これにより .NET Framework アプリケーションはチャネルに対するサブスクライブと発行を行うことができます。Redis サーバーへの接続の GetSubscriber メソッドを使用することで ISubscription オブジェクトを作成し、このオブジェクトの SubscribeAsync メソッドを使用することでチャネルのメッセージをリッスンします。次のコード例に、“messages:blogPosts” という名前のチャネルをサブスクライブする方法を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
await subscriber.SubscribeAsync("messages:blogPosts", (channel, message) =>
{
    Console.WriteLine("Title is: {0}", message);
});
```

Subscribe メソッドの最初のパラメーターは、チャネルの名前です。この名前はキャッシュのキーで使用されるものと同じ規則に従って付け、任意のバイナリ データを含めることができます。ただし、比較的短く意味のある文字列を使用して、良好なパフォーマンスと保守性を確保することをお勧めします。チャネルが使用する名前空間はキーが使用する名前空間とは別のものであるため、同じ名前を持つチャネルとキーを扱うことができますが、このことによりアプリケーション コードの管理が難しくなる場合があることに注意してください。

2 番目のパラメーターは、Action デリゲートです。このデリゲートは、チャネルに新しいメッセージが出現するたびに、非同期に実行されます。この例では、単にコンソールにメッセージを表示します (メッセージには、ブログの投稿のタイトルが含まれます)。

チャネルに発行するには、アプリケーションで Redis PUBLISH コマンドを使用します。StackExchange ライブラリは、この操作を実行する IServer.PublishAsync メソッドを提供します。次のコード スニペットに、“messages:blogPosts” チャネルにメッセージを発行する方法を示します。

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
BlogPost blogpost = ...;
subscriber.PublishAsync("messages:blogPosts", blogPost.Title);
```

発行/サブスクライブ メカニズムについて理解しておくべき点がいくつかあります。

- 複数のサブスクライバーが同じチャネルにサブスクライブでき、すべてのサブスクライバーがそのチャネルに発行されたメッセージを受信します。
- サブスクライバーは、サブスクライブした後に発行されたメッセージのみを受信します。チャネルはバッファリングされません。メッセージが発行されると、Redis インフラストラクチャは各サブスクライバーにメッセージをプッシュし、メッセージを削除します。
- 既定では、サブスクライバーは、送信された順序でメッセージを受信します。メッセージの数が多く、サブスクライバーとパブリッシャーの数も多い稼働率の高いシステムでは、メッセージの順次配信を保証すると、システムのパフォーマンスが低下する可能性があります。各メッセージが独立していて順序が重要ではない場合は、Redis システムによる同時処理を有効にして、応答性を高めることができます。StackExchange クライアントでこれを実現するには、サブスクライバーで使用する接続の PreserveAsyncOrder を false に設定します。```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  redisHostConnection.PreserveAsyncOrder = false;
  ISubscriber subscriber = redisHostConnection.GetSubscriber();
  ```

## 関連パターンとガイダンス

次のパターンは、アプリケーションでキャッシュを実装するときのシナリオにも関連することがあります。

- [キャッシュアサイド パターン](http://msdn.microsoft.com/library/dn589799.aspx): このパターンでは、データ ストアからキャッシュにデータをオンデマンドで読み込む方法について説明します。このパターンは、キャッシュに保持されているデータと、元のデータ ストア内のデータの一貫性の維持にも役立ちます。
- [シャーディング パターン](http://msdn.microsoft.com/library/dn589797.aspx): このパターンは、水平方向のパーティション分割に関する情報を提供し、大量のデータを格納したりそれらのデータにアクセスしたりするときのスケーラビリティを向上させます。

## 詳細情報

- Microsoft Web サイトの「[MemoryCache クラス](http://msdn.microsoft.com/library/system.runtime.caching.memorycache.aspx)」ページ。
- Microsoft Web サイトの「[キャッシュ](http://msdn.microsoft.com/library/windowsazure/gg278356.aspx)」ページ。
- Microsoft Web サイトの「[どの Azure Cache を利用すればよいですか。](http://msdn.microsoft.com/library/azure/dn766201.aspx)」ページ。
- Microsoft Web サイトの「[Azure In-Role Cache の構成モデル](http://msdn.microsoft.com/library/windowsazure/hh914149.aspx)」ページ。
- Microsoft Web サイトの「[タスク ベースの非同期パターン](http://msdn.microsoft.com/library/hh873175.aspx)」ページ。
- StackExchange.Redis の GitHub のリポジトリにある「[Pipelines and Multiplexers](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md)」(パイプラインとマルチプレクサー) ページ。
- Redis Web サイトの「[Redis Persistence](http://redis.io/topics/persistence)」(Redis の永続性) ページ。
- Redis Web サイトの「[Replication](http://redis.io/topics/replication)」(レプリケーション) ページ。
- Redis Web サイトの「[Redis Cluster Tutorial](http://redis.io/topics/cluster-tutorial)」(Redis クラスターのチュートリアル) ページ。
- Redis Web サイトの「[Partitioning: how to split data among multiple Redis instances](http://redis.io/topics/partitioning)」(パーティション分割: 複数の Redis インスタンス間でデータを分割する方法) ページ。
- Redis Web サイトの「[Using Redis as an LRU Cache](http://redis.io/topics/lru-cache)」(LRU キャッシュとしての Redis の使用) ページ。
- Redis Web サイトの「[Transactions](http://redis.io/topics/transactions)」(トランザクション) ページ。
- Redis Web サイトの「[Redis Security](http://redis.io/topics/security)」(Redis のセキュリティ) ページ。
- Azure のブログの「[Lap around Azure Redis Cache](http://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/)」(Azure Redis Cache に関する説明) ページ。
- Microsoft Web サイトの「[Running Redis on a CentOS Linux VM in Windows Azure](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx)」(Windows Azure の CentOS Linux VM 上での Redis の実行) ページ。
- Microsoft Web サイトの「[Azure Redis Cache 用の ASP.NET セッション状態プロバイダー](http://msdn.microsoft.com/library/azure/dn690522.aspx)」ページ。
- Microsoft Web サイトの「[Azure Redis Cache 用の ASP.NET 出力キャッシュ プロバイダー](http://msdn.microsoft.com/library/azure/dn798898.aspx)」ページ。
- Azure サイトの「[Azure Redis キャッシュ (プレビュー) の開発](http://msdn.microsoft.com/library/azure/dn690520.aspx)」ページ。
- Redis Web サイトの「[An Introduction to Redis data types and abstractions](http://redis.io/topics/data-types-intro)」(Redis のデータ型と抽象化の概要) に関するページ。
- StackExchange.Redis の Web サイトの「[Basic Usage](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md)」(基本的な使用法) ページ。
- StackExchange.Redis リポジトリの「[Transactions in Redis](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md)」(Redis のトランザクション) ページ。
- Microsoft Web サイトの「[Data Partitioning Guidance](http://msdn.microsoft.com/library/dn589795.aspx)」(データのパーティション分割のガイダンス)。

<!---HONumber=Oct15_HO3-->