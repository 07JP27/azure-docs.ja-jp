---
title: "Durable Functions のパフォーマンスとスケーリング - Azure"
description: "Azure Functions の Durable Functions 拡張機能の紹介。"
services: functions
author: cgillum
manager: cfowler
editor: 
tags: 
keywords: 
ms.service: functions
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: multiple
ms.workload: na
ms.date: 09/29/2017
ms.author: azfuncdf
ms.openlocfilehash: cc4c643b8d0e8de1b5c38ca7bb1b0193d6b0f05b
ms.sourcegitcommit: 3f33787645e890ff3b73c4b3a28d90d5f814e46c
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/03/2018
---
# <a name="performance-and-scale-in-durable-functions-azure-functions"></a>Durable Functions のパフォーマンスとスケーリング (Azure Functions)

パフォーマンスとスケーラビリティを最適化するには、[Durable Functions](durable-functions-overview.md) 固有のスケーリング特性を理解しておくことが重要です。

スケーリング動作を理解するには、Durable Functions が使用する、基になる Azure Storage プロバイダーの詳細を理解しておく必要があります。

## <a name="history-table"></a>履歴テーブル

履歴テーブルは、すべてのオーケストレーション インスタンスの履歴イベントを含む Azure Storage テーブルです。 インスタンスが実行されると、新しい行がこのテーブルに追加されます。 このテーブルのパーティション キーは、オーケストレーションのインスタンス ID から派生します。 これらの値は、ほとんどの場合ランダムであり、これにより、Azure Storage での内部パーティションの最適な分散が確保されます。

## <a name="internal-queue-triggers"></a>内部キュー トリガー

オーケストレーター関数とアクティビティ関数は、どちらも、関数アプリの既定のストレージ アカウント内の内部キューによってトリガーされます。 Durable Functions には、**コントロール キュー**と**作業項目キュー**という 2 種類のキューがあります。

### <a name="the-work-item-queue"></a>作業項目キュー

Durable Functions では、タスク ハブあたり 1 つの作業項目のキューがあります。 これは基本的なキューであり、Azure Functions の他の `queueTrigger` キューと同様に動作します。 このキューは、ステートレスな "*アクティビティ関数*" をトリガーするために使用されます。 Durable Functions アプリケーションが複数の VM にスケールアウトされた場合、作業項目キューの作業を取得するためにすべての VM が競合します。

### <a name="control-queues"></a>コントロール キュー

"*コントロール キュー*" は、単純な作業項目キューよりも高度なキューです。 それは、ステートフル オーケストレーター関数をトリガーするために使用されます。 オーケストレーター関数のインスタンスは、ステートフル シングルトンであるため、競合コンシューマー モデルを使用して VM 間に負荷を分散させることはできません。 代わりに、オーケストレーター メッセージが複数のコントロール キューに負荷分散されます。 これについては、以降のセクションで詳しく説明します。

コントロール キューには、さまざまな種類のオーケストレーション ライフサイクル メッセージが含まれます。 たとえば、[オーケストレーター コントロール メッセージ](durable-functions-instance-management.md)、アクティビティ関数の "*応答*" メッセージ、タイマー メッセージがあります。

## <a name="orchestrator-scale-out"></a>オーケストレーターのスケールアウト

アクティビティ関数はステートレスであり、VM の追加によって自動的にスケールアウトされます。 一方、オーケストレーター関数は、1 つまたは複数のコントロール キューに*パーティション化*されます。 コントロール キューの数は固定され、負荷の作成を開始した後で変更することはできません。

複数の関数ホスト インスタンスにスケールアウトする (通常は異なる VM で実行されます) と、各インスタンスは、いずれかのコントロール キューのロックを取得します。 このロックにより、1 つのオーケストレーション インスタンスのみが 1 つの VM で一度に実行されることが保証されます。 つまり、タスク ハブが 3 つのコントロール キューで構成されている場合、オーケストレーション インスタンスは 3 台もの VM に負荷分散できます。 VM を追加することで、アクティビティ関数を実行するための容量を増やすことができます。  ただし、追加リソースは、オーケストレーター関数を実行するために使用されることはありません。

次の図は、Azure Functions ホストがスケールアウトされた環境で ストレージ エンティティと対話する方法を示しています。

![スケール図](media/durable-functions-perf-and-scale/scale-diagram.png)

ご覧のとおり、すべての VM は、作業項目キューのメッセージを得るために競合します。 ただし、コントロール キューからメッセージを取得できるのは 3 台の VM のみであり、各 VM が 1 つのコントロール キューをロックします。

オーケストレーション インスタンスは、オーケストレーションのインスタンス ID に対して内部ハッシュ関数を実行することによって、コントロール キュー インスタンスに配分されます。 インスタンス ID は既定によりランダムに自動生成されます。これにより、使用可能なすべてのコントロール キューにインスタンスがバランスよく配分されることが保証されます。 現時点でサポートされるコントロール キューの既定のパーティション数は **4** です。

> [!NOTE]
> 現時点では、Azure Functions にコントロール キューのパーティションの数を構成することはできません。 [この構成オプションの実現にご協力ください](https://github.com/Azure/azure-functions-durable-extension/issues/73)。

一般に、オーケストレーター関数は、軽量であることを目的としているため、多くのコンピューティング能力を要求すべきではありません。 このため、スループットを向上させるためにコントロール キューの多数のパーティションを作成する必要はありません。 代わりに、重労働の大部分をステートレスなアクティビティ関数で実行することで、無限にスケールアウトできます。

## <a name="auto-scale"></a>自動スケール

従量課金プランで実行されるすべての Azure Functions と同じように、Durable Functions は、[Azure Functions のスケール コントローラー](https://docs.microsoft.com/azure/azure-functions/functions-scale#runtime-scaling)による自動スケールをサポートします。 スケール コントローラーは、作業項目キューと各コントロール キューの長さを監視し、それに従って VM インスタンスを追加または削除します。 時間の経過と共にコントロール キューの長さが増加した場合、スケール コントローラーは、コントロール キューのパーティション数に達するまで VM インスタンスの追加を続行します。 時間の経過と共に作業項目キューの長さが増加した場合、スケール コントローラーは、コントロール キューのパーティション数に関係なく、負荷と釣り合うまで VM インスタンスの追加を続行します。

## <a name="thread-usage"></a>スレッドの使用

オーケストレーター関数は、1 つのスレッドで実行されます。 これは、オーケストレーター関数の実行が決定論的であることを保証するために必要です。 この点を念頭に置いて、I/O 操作 (これはさまざまな理由で禁止されています)、ブロック操作、スピニング操作などのタスクによってオーケストレーター関数のスレッドを不必要にビジーにしないことが重要です。 I/O、ブロック、または複数のスレッドが必要になる可能性がある作業は、アクティビティ関数に移動させる必要があります。

アクティビティ関数は、通常のキューによってトリガーされる関数とまったく同じように動作します。 つまり、それらは、I/O を安全に実行し、CPU 集約型操作を実行し、複数のスレッドを使用できます。 アクティビティ トリガーはステートレスであるため、無制限の VM に対して自由にスケールアウトできます。

## <a name="next-steps"></a>次の手順

> [!div class="nextstepaction"]
> [Durable Functions 拡張機能のインストールとサンプル](durable-functions-install.md)
