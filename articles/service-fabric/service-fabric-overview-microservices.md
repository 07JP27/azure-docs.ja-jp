<properties
   pageTitle="マイクロサービスの概要 | Microsoft Azure"
   description="マイクロサービスでクラウド アプリケーションを構築することが現代のアプリケーション開発にとって重要である理由と Azure Service Fabric がそれを達成するためのプラットフォームを提供するしくみの概要"
   services="service-fabric"
   documentationCenter=".net"
   authors="msfussell"
   manager="timlt"
   editor="bscholl"/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="03/24/2016"
   ms.author="msfussell"/>

# マイクロサービスの手法でアプリケーションを構築する理由は何ですか。
ソフトウェア開発者にとって、アプリケーションを構成要素化することは新しい手法ではありません。これは、オブジェクト指向、ソフトウェア抽象化、コンポーネント化の中心的なパラダイムです。今日、この要素化はクラスや共有ライブラリとテクノロジ層のインターフェイスという形態を取り、一般的に、バックエンド ストア、ミドル層ビジネス ロジック、フロントエンド UI による階層型手法で行われています。ここ数年で変化*した*ことは、開発者がビジネス主導のクラウドのために分散アプリケーションを構築しているということです。

変化するビジネス ニーズには次のようなものがあります。

- 顧客リーチを拡大する、たとえば、新しい地理的地域に進出することを可能にする、または顧客の場所でデプロイする必要のない規模のサービスを構築し、運用するニーズ。
- 顧客の要望にアジャイルに応答する機能を短期間で届ける。
- リソース利用率を改善し、コストを下げる。

これらのビジネス ニーズが、アプリケーションの構築*方法*に影響します。

マイクロサービスに対する Azure のアプローチの詳細については、「[Microservices: An application revolution powered by the cloud (マイクロサービス: クラウドによって実現されるアプリケーションの革命)](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)」を参照してください。

## モノリシックとマイクロサービスのデザイン アプローチの比較
すべてのアプリケーションは時間の経過に伴って進化します。成功したアプリケーションは便利であることで進化します。失敗したアプリケーションは進化せず、最終的には廃止となります。問題は、現在の要件についてどれだけ知っているかと、その要件が将来どうなると思うかということです。 たとえば、ある部署のためにレポート アプリケーションを構築する際に、そのアプリケーションが社内で使用され、レポートの存続期間は短いことがわかっている場合、選択する手法は、たとえば、数千万の顧客にビデオ コンテンツを配信するサービスを構築する場合とは異なります。アプリケーションは後で再設計可能であると承知した上で、何かを概念実証として完成させることが推進要因となることがあります。利用されないものをオーバースペックにすることは、ほとんど意味がありません。これは、普通、エンジニアリング上の得失評価となります。一方、企業がクラウドの構築について話す際に、成長と利用が期待されます。問題はその成長と規模が予想できないことです。早期に試作品を作成し、同時に、将来の成功に対処するための道を歩んでいることを確認することが望まれます。これが、構築、測定、学習、繰り返しからなるリーン スタートアップ手法です。

クライアント/サーバーの時代には、各層で特定の技術を利用する階層型アプリケーションを構築する傾向にありました。このような手法で、"モノリシック" アプリケーションという言葉が登場しました。インターフェイスが階層間に存在するようになり、各層内のコンポーネント間ではより緊密に結合した設計が使用されました。開発者はライブラリにコンパイルするクラスを設計し、要素化し、リンクしていくつかの exe や dll を作成しました。このようなモノリシック設計の手法には長所があります。設計がより単純になり、多くの場合、IPC 経由となるため、コンポーネント間の呼び出しが速くなります。また、誰もが 1 つの製品をテストし、人的リソース効率が良くなります。欠点は、アプリケーションが階層内で緊密に結合され、個々のコンポーネントを拡張できないことです。修正やアップグレードを行う場合、他の開発者がテストを完了するのを待たなければならず、アジャイルにすることがより難しくなります。

マイクロサービスはこのような欠点に対処しており、上記のビジネス要件に合わせて調整されますが、マイクロサービスにも利点と欠点があります。マイクロサービスの利点は、通常、各マイクロサービスがより単純なビジネス機能をカプセル化し、独立して拡大縮小、テスト、デプロイ、管理できることです。マイクロサービス手法の重要な利点の 1 つは、チームが技術主導ではなくビジネス シナリオ主導になる傾向があることです。技術主導であれば、階層型の手法が奨励されます。つまり、実際には、小規模のチームが選択した技術を利用し、顧客シナリオに基づいてマイクロサービスを開発します。言い換えれば、組織はモノリシックを維持する目的で技術を標準化する必要がありません。さらに、サービスを所有する個々のチームは、チームの専門知識に基づいてチームに適したアクション、またはそのサービスで解決しようとしている問題に最適なアクションを実行できます。実際には、特定の NoSql ストアや Web アプリケーション フレームワークなど、一連の推奨技術を用意することが望ましくなります。マイクロサービスの欠点には、数が増加した個々のエンティティの管理、より複雑なデプロイメントの処理とバージョン管理、マイクロサービス間のネットワーク トラフィックの増加、対応するネットワークの待ち時間などがあります。煩雑で非常に細かなサービスが多いことは、パフォーマンス上の悩みの種です。依存関係を表示するための支援ツールがなければ、システム全体を "見る" ことが困難になります。最終的には、標準に基づいてマイクロサービス手法を機能させることになります。その場合、通信方法について同意し、厳密なコントラクトではなく、サービスから必要となるものだけを許容します。サービスは互いに独立して更新されるため、設計にこれらの連絡先をあらかじめ定義することが重要です。マイクロサービス手法による設計を別の言葉で表現すると "詳細な SOA" となります。


***簡単に言うと、マイクロサービスの設計手法とは、サービスの切り離されたフェデレーションであり、各サービスの変更が独立して行われ、同意した通信標準が使用されます。***


生成されるクラウド アプリの数が増えるにつれ、アプリ全体を独立したシナリオ中心のサービスに分割するこの手法が長期的には優れた手法であることに気付く人が増えています。
## アプリケーション開発手法の比較

![Service Fabric プラットフォーム アプリケーションの開発][Image1]

1. モノリシック アプリにはドメイン固有の機能が含まれ、通常は、Web、ビジネス、データなどの、機能層で分割されます。

2. 複数のサーバー/VM/コンテナーでクローンを作成することで、モノリシック アプリを拡張します。

3. マイクロサービス アプリケーションは機能をより小規模の個別サービスに分割します。

4. この手法では、各サービスを個別にデプロイすることで拡張し、サーバー/VM/コンテナーにわたってこれらのサービスのインスタンスを作成します。


あらゆるプロジェクトをマイクロサービス手法で設計できるわけではありませんが、前述のビジネスの目的により厳密に合わせることができます。また、後で必要に応じてマイクロサービス設計用にコードを書き直せることがわかっている場合は、モノリシック手法を最初から使用してもかまいません。一般的には、モノリシック アプリを作成し、それを段階的に徐々に分割します。その場合、拡張性またはアジャイル性を高める必要がある機能領域から始めます。

要約すると、マイクロサービス手法とは、マシンのクラスター全体にデプロイされたコンテナーで実行する、多数の小規模サービスからなるアプリケーションを作成することです。各サービスは 1 つのシナリオに重点を置く小規模のチームによって開発され、個別にテスト、デプロイ、拡張されるため、アプリケーション全体を進化させることができます。

## マイクロサービスとは何か。

マイクロサービスにはさまざまな定義があり、インターネットを検索すれば、それぞれの視点と定義を提示する多くの優れたリソースが見つかります。ただし、マイクロサービスの次の特性の多くは一般に受け入れられています。

- 顧客またはビジネス シナリオをカプセル化します。どのような問題を解決していますか。
- 小規模のエンジニアリング チームによって開発されます。
- あらゆるプログラミング言語で記述し、あらゆるフレームワークを使用できます。
- 個別にバージョン管理、デプロイ、拡張されるコードとステート (任意) で構成されます。
- 適切に定義されたインターフェイスとプロトコルで他のマイクロサービスと通信します。
- 場所の解決に使用できる一意の名前 (URL) があります。
- エラーが発生しても、一貫性を維持し、利用できます。

これを次のようにまとめることができます。

***マイクロサービス アプリケーションは、適切に定義されたインターフェイスと標準プロトコルで互いに通信する、個別にバージョン管理され、拡張可能な小規模の顧客中心サービスから構成されます。***


前のセクションでは、上記の最初の 2 点について説明しました。ここでは、他の点について詳しく説明します。

### あらゆるプログラミング言語で記述し、あらゆるフレームワークを使用できます
開発者は、技能とサービスのニーズに合わせ、言語やフレームワークを自由に選択できなければなりません。サービスによっては、C++ のパフォーマンス上の利点が他のすべてのものより重視されることもあれば、C# や Java の管理開発の容易さが最も重要になることがあります。場合によっては、特定のサードパーティ ライブラリ、データ ストレージ技術、クライアントにサービスを公開する手法の使用が必要になります。

技術を選択したところで、サービスの運用またはライフサイクル管理および拡張に関する話題に移ります。

### コードとステートを個別にバージョン管理、デプロイ、および拡張できるようにする  

ただし、マイクロサービスを記述することにした場合は、コードとステート (任意) の両方について、それぞれ個別にデプロイ、アップグレード、拡張する必要があります。これは、結局、技術の選択と、拡張に関しては、コードとステートの両方のパーティショニング (またはシャーディング) 方法の理解の問題になるため、実際には解決が難しい問題の 1 つです。コードとステートで別々の技術が使用される場合 (今日、その傾向にあります)、マイクロサービスのデプロイメント スクリプトは両方を拡張できるものでなければなりません。また、これはアジャイル性と柔軟性にも影響するため、一部のマイクロサービスをアップグレードする場合、それらをすべて一度にアップグレードする必要はありません。少しの間、モノリシックとマイクロサービスの手法の比較に戻り、下の図にステートの格納方法の違いを示します。

#### アプリケーション スタイル間のステート ストレージ
![Service Fabric プラットフォームのステート ストレージ][Image2]

***左は、1 つのデータベースと特定のテクノロジ層からなるモノリシック手法です。***

***右はマイクロサービス手法であり、グラフではマイクロサービスが相互に接続されています。一般的にステートの対象はマイクロサービスであり、さまざまなテクノロジが利用されます。***

モノリシック手法では、通常、1 つのデータベースがアプリケーションに利用されます。長所はこれが単一の場所であり、デプロイが簡単になることです。各コンポーネントには、そのステートを格納するテーブルを 1 つ与えることができます。難点はチームが厳密にステートを分離しなければならないことです。そのため、必然的に、単に既存の顧客テーブルに新しい列を追加し、テーブル間で結合を行い、一般にストレージ層で依存関係を作ってしまう傾向にあります。このような場合、個々のコンポーネントを拡張することはできません。マイクロサービス手法では、各サービスがそのステートを管理し、格納します。つまり、サービスの要求に応じて、コードとステートの両方をまとめて拡張する役割を担います。この手法の欠点は、アプリケーション データのビュー (またはクエリ) を作成しなければならないということです。さまざまなステート ストアにわたりクエリを実行する必要があるためです。通常、この問題は、マイクロサービスの集合全体でビューを構築する個別のマイクロサービスを用意することで解決されます。データに対して複数のアドホック クエリを実行する必要がある場合、各マイクロサービスでは、オフライン分析のためにデータ ウェアハウス サービスにそのデータを書き込むことを検討する必要があります。


バージョン管理はデプロイされたバージョンのマイクロサービスに固有です。複数の異なるバージョンをロールアウトし、並列で実行できるようにするために必要です。バージョン管理は、アップグレード中に新しいバージョンのマイクロサービスにエラーが発生し、前のバージョンにロールバックしなければならない状況に対処します。バージョン管理の他のシナリオは、「異なるユーザーが異なるバージョンのサービスを試す場合に、A/B スタイルの試験を実行する」ものです。たとえば、特定の集合の顧客に対してマイクロサービスをアップグレードし、新しい機能をテストしてからより広い範囲でロールアウトするのが一般的です。マイクロサービスのライフサイクル管理の次は、マイクロサービス間の通信について説明します。


### 明確に定義されたインターフェイスとプロトコルで他のマイクロサービスと通信します

過去 10 年間に公開されたサービス指向アーキテクチャに関する広範囲の文書を読む以外、このトピックで取り上げることはほとんどありません。この大半が通信パターンを対象にしているためです。現状では、一般的に、HTTP と TCP プロトコル、およびシリアル化形式として XML または JSON を適用する REST 手法を使用することになります。インターフェイスの観点では、Web 設計手法を採用することになります。ただし、バイナリ プロトコルや独自のデータ形式を使用しても問題はありません。マイクロサービスが公開されたときに、ユーザーがそれを使いこなせない場合に備えるだけです。

### 場所の解決に使用される一意の名前 (URL) が与えられる

マイクロサービス手法は Web に似ていることは繰り返しお伝えしています。 Web と同様に、マイクロサービスは、実行される場所に関係なく、アドレス指定できるものでなければなりません。どのマシンがどのマイクロサービスを実行しているのかわからないようであれば、事態はすぐに悪化します。DNS が特定の URL を特定のマシンに解決するように、現在地を検出するための一意の名前をマイクロサービスに与える必要があります。マイクロサービスにはアドレス指定可能な名前を与え、実行されているインフラストラクチャから独立させる必要があります。これは、サービスのデプロイ方法と検出方法の間に対話があることを暗示します。サービス レジストリが必要になるためです。同様に、マシンでエラーが発生するタイミングとマイクロサービスの動作の間にも対話が必要になります。それにより、レジストリ サービスは現在の実行場所を伝えることができます。それでは回復力と一貫性に関する次のトピックに移ります。

### エラーが発生しても、一貫性を維持し、利用できます

予期しないエラーの対処は、特に分散システムにおいて、解決が最も難しい問題の 1 つです。開発者が記述するコードの大半は例外を処理し、テストでもこれにほとんどの時間が費やされます。しかし、エラーを処理するコードを記述する以上に問題は複雑です。マイクロサービスが実行されているマシンでエラーが発生した場合、どうなるでしょうか。 このマイクロサービスのエラーを検出する必要があるだけでなく (これ自体も難問ですが)、マイクロサービスを再起動する方法も必要になります。マイクロサービスは故障に強くなければなりません。別のマシンで再起動し、可用性を維持する機能が必要になります。また、マイクロサービスに代わって保存されたステート、このステートを復元できる場所、正常に再起動できるかどうかが重要になります。言い換えると、コンピューティングに回復力が必要である (つまり、プロセスが再起動される) だけでなく、ステートやデータにも回復力が必要になります (データの損失がなく、データの一貫性が維持される)。

回復力の問題は、アプリケーション アップグレード中にエラーが発生する場合などに、さらに複雑になります。マイクロサービスは、デプロイメント システムと連動して、回復すればいいだけではありません。継続的に新しいバージョンに移行するか、前のバージョンにロールバックして一貫性のある状態を維持できるようにするかを決定する必要もあります。継続的に移行できる十分なマシンがあるかどうかや、前のバージョンのマイクロサービスを復元する方法などの問題を考慮する必要があります。このような決定を行うために、マイクロサービスは正常性情報を送信する必要があります。

### 正常性と診断の報告

明白なことと思われますが (それでも、見落とされることがよくある)、マイクロサービスが正常性と診断を報告することは非常に重要です。報告しなければ、運用の観点からほとんど洞察は得られません。サービスの集合に依存性がなく、各サービスのログが個別に記録され、マシンのクロック スキューを処理しなければ診断イベントの順番がわからないような状況では、イベントの相関関係を理解することが課題になります。同様に、同意したプロトコルとデータ形式でマイクロサービスと対話する場合、正常性と診断イベントのログ方法の標準化が必要になり、結局は、クエリと表示が可能なイベント ストアが必要になります。マイクロサービス手法では、異なるチームが 1 つのログ形式に同意することが重要です。全体としてアプリケーションで診断イベントを表示する場合に、一貫性のある手法が必要になるためです。

正常性は診断とは異なります。適切な措置を講じるためにマイクロサービスがその現状を報告するのが正常性です。アップグレードとデプロイメントのメカニズムで可用性を維持する場合に、その違いは明らかです。たとえば、プロセスのクラッシュやマシンの再起動に起因し、現在、サービスの状態が正常でないとしても、動作は続きます。この場合、アップグレードを実行して事態を悪化させてはなりません。最初に調査するか、マイクロサービスに回復時間を与えることが最良の方法です。マイクロサービスからの正常性イベントにより得られた十分な情報に基づいて判断することができ、実際、自己回復サービスの作成に役立ちます。

## マイクロサービス プラットフォームとしての Service Fabric

Azure Service Fabric は、Microsoft が箱入り製品 (通常、モノリシック スタイル) の提供からサービスの提供に移行する過程で生まれたものです。Azure SQL データベース、DocumentDB、その他のコア Azure サービスなど、大規模なサービスを構築し、運用した経験が主な原動力でした。全体的に、スケール、アジャイル性、独立したチームのビジネス ニーズに取り組んだものであり、このプラットフォームは、それを採用するサービスが増えるにつれ、時間と共に進化しています。重要なことは、Service Fabric はどこでも (Azure だけではなく、スタンドアロン Windows Server デプロイメントでも) 実行できる必要があったということです。

***Service Fabric の目的は、障害やアップグレードなど、サービスの構築と実行に伴う難問を解決することであり、チームがマイクロサービス手法でビジネス上の問題を解決できるようにインフラストラクチャ リソースを効率的に活用します。***

Service Fabric では、2 つの広範領域でマイクロサービス手法によるアプリケーションの構築を支援します。

- デプロイメント、アップグレード、障害が発生したサービスの検出と再始動、サービスが現在実行されている場所の検出、ステート管理、正常性の監視などを処理する一連のシステム サービスからなるプラットフォーム。実際、このようなシステム サービスにより、前述のマイクロサービスの特性の多くが可能になります。

-  マイクロサービスとしてのアプリケーションの構築を支援するプログラミング API またはフレームワーク。提供されるプログラミング API は [Reliable Actors および Reliable Services](service-fabric-choose-framework.md) と呼ばれています。もちろん、どのコードを使用してもマイクロサービスを構築できます。しかし、これらの API を利用すれば、作業が単純になり、より深いレベルでプラットフォームと統合されます。この方法では、たとえば、正常性や診断に関する情報が得ることができ、また、組み込みの高可用性を利用することができます。

***Service Fabric はサービスの構築方法に依存しないため、任意のテクノロジを利用できます。しかし、マイクロサービスの構築を非常に簡単にする組み込みのプログラミング API が提供されます。***

### 私のアプリケーションにマイクロサービスは適しているでしょうか。

その可能性はあります。経験から申し上げると、Microsoft では、ビジネス上の理由からクラウドの構築を要請されるチームが増えるにつれ、チームの多くがマイクロサービスと同様の手法を利用する利点を実感しています。たとえば、Bing では、何年もの間、この手法を検索に取り入れています。他のチームにとって、これは不慣れな手法でした。解決しなければならない難問があり、それが短所であることがわかりました。そこで Service Fabric がサービス構築技術として注目されました。

Service Fabric の目的は、マイクロサービス手法によるアプリケーション構築の複雑性を減らすことです。複雑性が減れば、多くのコストがかかる再設計を繰り返す必要がなくなります。小規模なものから始める、必要に応じて拡張する、サービスを廃止する、新しいサービスを追加する、顧客の利用状況に合わせて進化することがマイクロサービス手法です。実際には、大部分の開発者にマイクロサービスをよりわかりやすくするために解決する必要がある問題がまだ多く残っていることもわかっています。コンテナーとアクター プログラミング モデルはその方向に進む小さな一歩としての例です。さらに多くの革新的技術が開発され、簡易化が進むことをマイクロソフトは確信しています。
<!--Every topic should have next steps and links to the next logical set of content to keep the customer engaged-->
## 次のステップ

* 詳細:
	* [Service Fabric の概要](service-fabric-overview.md)
    * [Microservices: An application revolution powered by the cloud (マイクロサービス: クラウドによって実現されるアプリケーションの革命)](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)

[Image1]: media/service-fabric-overview-microservices/monolithic-vs-micro.png
[Image2]: media/service-fabric-overview-microservices/statemonolithic-vs-micro.png

<!---HONumber=AcomDC_0518_2016-->