<properties
   pageTitle="Reliable Collection | Microsoft Azure"
   description="Service Fabric ステートフル サービスは、可用性と拡張性が高く、待機時間が短いクラウド アプリケーションの記述を可能にする Reliable Collection を提供します。"
   services="service-fabric"
   documentationCenter=".net"
   authors="mcoskun"
   manager="timlt"
   editor="masnider,jessebenson"/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="required"
   ms.date="10/15/2015"
   ms.author="mcoskun"/>

# Service Fabric ステートフル サービスの Reliable Collection の概要

Reliable Collection では、高可用性でスケーラブルなほか、待機時間が短いクラウド アプリケーションを、単一マシン アプリケーションを作成しているかのように作成できます。`Microsoft.ServiceFabric.Data.Collections` 名前空間のクラスは、状態の可用性を自動的に高める、すぐに使用可能な一連のコレクションを提供します。開発者は Collection API をプログラムする必要があるだけで、レプリケートされたローカルの状態は Reliable Collection によって管理されます。

Reliable Collection とその他の高可用性テクノロジ (Redis、Azure Table サービス、Azure Queue サービスなど) の主な違いは、状態をローカルでサービス インスタンスに格納したまま、高い可用性を実現している点です。これは、次のことを意味します。

1. すべての読み取りはローカルで実行されるため、待機時間が短くスループットが高い読み取りになります。
2. すべての書き込みではネットワーク IO 回数が最小に抑えられるため、待機時間が短くスループットが高い書き込みになります。

![コレクションの進化のイメージです。](media/service-fabric-reliable-services-reliable-collections/ReliableCollectionsEvolution.png)

Reliable Collection は `System.Collections` クラスが自然に進化したものだと考えられます。つまり、クラウド アプリケーションや複数マシン アプリケーション向けに設計された、開発者の作業を複雑にしない一連の新しいコレクションということです。そのため Reliable Collection には次の特長があります。

1. レプリケートされる: 状態の変更がレプリケートされるため、高可用性を実現できる。
2. 永続化される: データがディスクに永続化されるため、大規模な障害 (例: データセンターの電源障害) が発生しても影響を受けない。
3. 非同期: API は 非同期であるため、IO の実行時にスレッドがブロックされない。
4. トランザクション: API ではトランザクションの抽象化が使用できるため、サービス内で複数の Reliable Collection を簡単に管理できる。

Reliable Collection では追加設定なしで強力な整合性が保証されるため、アプリケーションの状態を判断するのが簡単です。強力な整合性は、プライマリ レプリカを含むレプリカのクォーラムにトランザクション全体が適用された後にのみ、トランザクション コミットが完了することを徹底することで実現されています。弱い整合性の場合、非同期コミットが戻される前に、アプリケーションがクライアントや要求元に応答します。

Reliable Collection API は同時実行コレクション API (`System.Collections.Concurrent` 名前空間内にあります) が進化したものです。

1. 非同期: 同時実行コレクションとは異なり、操作がレプリケートおよび永続化されるため、タスクを返します。
2. out パラメーターを使用しない: `ConditionalResult<T>` を使用して out パラメーターではなく、ブール値および値を返します。`ConditionalResult<T>` は `Nullable<T>` に似ていますが、構造体にするには「T」は必要ありません。
3. トランザクション: トランザクション オブジェクトを使用することで、トランザクション内で複数の Reliable Collection に対してユーザーがグループ操作を実行できます。

現在、`Microsoft.ServiceFabric.Data.Collections` には次の 2 つのコレクションが含まれています。

1. [Reliable Dictionary](https://msdn.microsoft.com/library/azure/dn971511.aspx): レプリケートされた、トランザクションに使用する非同期のキーと値のペアのコレクションです。`ConcurrentDictionary` のように、キーと値のいずれにも任意の型を使用できます。
2. [Reliable Queue](https://msdn.microsoft.com/library/azure/dn971527.aspx): レプリケートされた、トランザクションに使用する非同期の厳密な先入れ先出し型 (FIFO) のキューです。`ConcurrentQueue` のように、値には任意の型を使用できます。

## 分離レベル
分離レベルは、達成された分離の程度を示します。分離されているということは、いかなるときでも 1 つのトランザクションのみが実行されるということで、システム内でのトランザクションの通常処理が実行されていることになります。

Reliable Collection では、レプリカの操作とロールに合わせて、特定の読み取り操作に使用する分離レベルが自動的に選択されます。

Reliable Collection では、次の 2 つの分離レベルがサポートされています。

- **反復可能読み取り**: "変更されたが、まだ他のトランザクションによってコミットされていないデータをステートメントから読み取ることができないように指定するほか、現在のトランザクションが完了するまで、現在のトランザクションで読み取られたデータをその他のトランザクションが変更できないように指定します。(https://msdn.microsoft.com/ja-JP/library/ms173763.aspx)"
- **スナップショット**: "トランザクションの任意のステートメントによって読み取られたデータが、トランザクションの開始時に存在していた、トランザクション全体を通じて整合性のあるバージョンのデータになることを指定します。トランザクションで認識されるのは、トランザクション開始前にコミットされたデータ変更のみです。現在のトランザクションの開始後に他のトランザクションによって行われたデータ変更は、現在のトランザクションで実行されているステートメントには認識されません。それはつまり、トランザクションの開始時に存在していたコミット済みデータのスナップショットを、トランザクション内のステートメントが取得しているかのように機能するということです (https://msdn.microsoft.com/ja-JP/library/ms173763.aspx))"

Reliable Dictionary と Reliable Queue では、Read Your Writes がサポートされます。つまり、トランザクション内でのすべての書き込みは、同じトランザクションで行われる次の読み取りによって認識されるということです。

### Reliable Dictionary
| 操作\\ロール | プライマリ | セカンダリ |
| --------------------- | :--------------- | :--------------- |
| 1 つのエンティティの読み取り | 反復可能読み取り | スナップショット |
| 列挙\\カウント | スナップショット | スナップショット |

### Reliable Queue
| 操作\\ロール | プライマリ | セカンダリ |
| --------------------- | :--------------- | :--------------- |
| 1 つのエンティティの読み取り | スナップショット | スナップショット |
| 列挙\\カウント | スナップショット | スナップショット |

## 永続性モデル
Reliable State Manager および Reliable Collection は、ログとチェックポイントと呼ばれる永続性モデルに従います。このモデルでは、各状態の変更がディスクにログ記録され、メモリにのみ適用されます。完全な状態が永続化されるのはごくまれです (チェックポイントとしても知られています)。このモデルを使用する利点は次のとおりです。

- 差分がディスクに対する追加専用のシーケンシャル書き込みに変換されるため、パフォーマンスが向上する。

ログとチェックポイント モデルをよく理解するために、まず無限のディスクのシナリオを見てみましょう。Reliable State Manager が、すべての操作をレプリケートされる前にログ記録します。これにより、Reliable Collection はメモリにおいてのみ操作を適用できます。ログは永続化されるため、レプリカに障害が発生して再起動する必要があった場合でも、Reliable State Manager のログに十分な情報があるため、レプリカで失われたすべての操作を再生することができます。ディスクは無限であるためログ レコードを削除する必要はなく、Reliable Collection が実行する必要があるのは、メモリ内にある状態を管理することだけです。

次に、有限のディスクのシナリオを見ていきましょう。ある時点で、Reliable State Manager が使用するディスク領域が不足します。そのような不足が発生する前に、Reliable State Manager は、ログを切り捨てて新しいレコードを格納する領域を確保する必要があります。このとき Reliable State Manager は、メモリ内の状態をチェックポイントとしてディスクに記録するように Reliable Collection に要求します。その時点までの状態を永続化するのは Reliable Collection の役目です。Reliable Collection がチェックポイントを完了すると、Reliable State Manager はログを切り捨ててディスク領域を解放できます。このようにして、レプリカの再起動が必要な場合、Reliable Collection はチェックポイントされた状態を回復し、Reliable State Manager はチェックポイント以降に実行された状態の変更すべてを回復して再生します。

## ロック
Reliable Collection では、すべてのトランザクションは 2 段階で実行されます。つまり、トランザクションが中止またはコミットのいずれかで終了するまで、取得したロックを解放しないということです。

Reliable Collection は、常に排他ロックを取得します。読み取りの場合、ロックはいくつかの要因によって使用方法が異なります。スナップショット分離を使用して行う読み取り操作ではロックは使用されません。反復可能読み取り操作では、既定で共有ロックを取得します。ただし、反復可能な読み取りをサポートするすべての読み取り操作の場合、ユーザーは共有ロックではなく更新ロックを要求できます。更新ロックは、複数トランザクションにおいて、後で必要になるかもしれない更新のためにリソースをロックするときによく発生するデッドロックを防ぐための非対称ロックです。

次に示すのは、ロックの互換性対応表です。

| 要求\\許可 | なし | 共有 | 更新 | 排他的 |
| ----------------- | :----------- | :----------- | :---------- | :----------- |
| 共有 | 競合なし | 競合なし | 競合 | 競合 |
| 更新 | 競合なし | 競合なし | 競合 | 競合 |
| 排他的 | 競合なし | 競合 | 競合 | 競合 |

デッドロック検出のために、Reliable Collection API の timeout 引数が使用されることに注意してください。たとえば、2 つのトランザクション (T1 と T2) が K1 を読み取って更新しようとしているとします。いずれも共有ロックを取得することになるため、両方にデッドロックが発生する可能性があります。この場合、一方または両方の操作がタイムアウトになります。

上記のデッドロックのシナリオは、デッドロックを更新ロックによって回避する良い例です。

## 推奨事項

- 読み取り操作によって返されるカスタム型のオブジェクトを変更**しないでください** (例: `TryPeekAsync` または `TryGetAsync`)。Reliable Collection は、同時実行コレクションのように、コピーではなくオブジェクトへの参照を返すからです。
- 返されたカスタム型のオブジェクトは、変更する前に**詳細コピー**してください。構造体型と組み込み型は値渡しであるため、詳細コピーを実行する必要はありません。
- タイムアウトに `TimeSpan.MaxValue` を使用**しないでください**。タイムアウトはデッドロックの検出に使用してください。
- 別のトランザクションの `using` ステートメント内にトランザクションを作成**しないでください**。デッドロックを引き起こす可能性があるためです。

次の点に注意してください。

- すべての Reliable Collection API の既定のタイムアウトは 4 秒です。ほとんどの場合において、ユーザーがこれをオーバーライドすることはお勧めしません。
- すべての Reliable Collection API で、既定のキャンセル トークンは `CancellationToken.None` です。
- 列挙体は、コレクション内で整合性のあるスナップショットです。ただし、複数コレクションの列挙体にはコレクション間での整合性はありません。
- Reliable Collection で高可用性を実現するには、各サービスに少なくとも 1 つのターゲットと、最低 3 台で構成されるレプリカ セットが必要です。

## 次のステップ

- [Reliable Service のクイック スタート](service-fabric-reliable-services-quick-start.md)
- [Service Fabric Web API サービスの概要](service-fabric-reliable-services-communication-webapi.md)
- [Reliable Service プログラミング モデルの詳細な使用方法](service-fabric-reliable-services-advanced-usage.md)
- [Reliable Collection の開発者向けリファレンス](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)

<!---HONumber=Nov15_HO2-->