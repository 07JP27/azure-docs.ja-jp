<properties
   pageTitle="Reliable Actors のパターンとアンチパターン | Microsoft Azure"
   description="アクター プログラミング モデルの概要、Service Fabric Reliable Actors と効果的に連動する設計パターン、回避するべきアンチパターンを提供します。"
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/11/2015"
   ms.author="vturecek"/>

# Reliable Actors の設計パターンの概要

Azure Service Fabric の Reliable Actors プログラミング モデルは、クラウド スケールで現実の問題を解決するためにアクター モデルに基づいて構築されたプラットフォームです。Service Fabric は、開発と管理が容易な信頼性の高いスケーラブルなアプリケーションをクラウドとオンプレミスの両方で構築するためのプラットフォームです。

この記事は、実際問題に関する実用的な説明を意図しています。さまざまなパターンを通読したら、Reliable Actor モデルを使用して、エンタープライズまたはクラウド ソリューションを構築する方法を理解できるはずです。

## パターン

このセクションでは、顧客との契約時に採用される一連のパターンと関連するシナリオの一覧を示します。これらのパターンは、お客様が Microsoft Azure でビルドする広範なソリューションに該当する問題のクラスを表します。シナリオは実際のケースに基づいていますが、パターンがより明確になるようにドメイン固有の問題のほとんどを除去しました。ほとんどのサンプル コードは単純で明白なことがわかるでしょう。コードが含まれているのは完全を期すためであり、特にそれ以外の意味はありません。

ここに示すパターンはすべてでも標準でもありません。開発者によっては、ここに提示するものと異なる方法で同じ問題やパターンを解決することがあります。

[パターン: スマート キャッシュ](service-fabric-reliable-actors-pattern-smart-cache.md)

[パターン: 分散ネットワークとグラフ](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[パターン: リソースのガバナンス](service-fabric-reliable-actors-pattern-resource-governance.md)

[パターン: ステートフル サービスの構成](service-fabric-reliable-actors-pattern-stateful-service-composition.md)

[パターン: モノのインターネット](service-fabric-reliable-actors-pattern-internet-of-things.md)

[パターン: 分散計算](service-fabric-reliable-actors-pattern-distributed-computation.md)

[いくつかのアンチパターン](service-fabric-reliable-actors-anti-patterns.md)

### アクターの簡単な歴史

Carl Hewitt と共同執筆者がアクター モデルを生み出した[論文](http://dl.acm.org/citation.cfm?id=1624804)が 1973 年に公開されました。しかしながら、分散システムにおける同時性と複雑性に対処するする手段としてアクター モデルが注目を集め始めたのは比較的最近のことです。

アクター モデルは、相互に分離された微少な個別オブジェクトであるアクターをサポートします。アクターは非同期メッセージを受け渡して通信し、アクター間で直接通信できます。アクターは、単一スレッドのセマンティクスで実行します。アクターの状態のカプセル化と他のアクターからの分離と併せて、高度に並列的なシステムを簡単に作成できます。これは同時実行に関する問題をアクターのコードから除去することで実現します。アクターは、利用可能なハードウェア リソースのプール上に動的に作成されます。

[Erlang](http://www.erlang.org/) は、アクター モデルの最も一般的な実装です。開発者はアクター モデルを再発見するようになり、新たな関心が呼び起こされ、Erlang や Erlang に似た新しいソリューションである [Scala](http://www.scala-lang.org/) アクター、[Akka](http://akka.io)、[Akka.NET](http://getakka.net/)、[DCell](http://research.microsoft.com/pubs/75988/dcell.pdf) を作成するようになりました。

## Service Fabric Reliable Actors の長所

Reliable Actors プログラミング モデルは、Erlang や分散オブジェクト システムからアイディアを拝借してアクター モデルを実装するものです。アクター間接参照の層を追加し、Service Fabric プラットフォームを活用する統合プログラミング モデルでアクターを公開します。

Reliable Actors の主な長所は、エキスパート プログラマーでなくても**開発生産性が高く**、プログラマーが特別なことをしなくても**もともと透過的な拡張性を備えている**ことです。Reliable Actors プログラミング モデルでは、.NET ライブラリを利用し、Service Fabric の上で実行します。複雑な分散アプリケーションの開発を簡単にするツールを提供します。また、そのようなツールでは、拡張可能なアプリケーションを設計できます。以下ではこれらの利点についてさらに説明します。このプログラミング モデルは、以下の重要な抽象化、保証、およびシステム サービスを提供することで、上級者と初心者の両方のプログラマーの生産性を向上させます。

* 使い慣れたオブジェクト指向プログラミング (OOP) パラダイム。アクターは、非同期メソッドおよびプロパティを備えた宣言済みの .NET アクター インターフェイスを実装する .NET クラスです。そのため、プログラマーからは、アクターはメソッド/プロパティを直接呼び出すことができるリモート オブジェクトのように見えます。これにより、メソッドの呼び出しをメッセージにして、正しいエンドポイントにルーティングし、ターゲット アクターのメソッドを呼び出して、エラーや困難なケースを完全に透過的な方法で処理することにより、使い慣れた OOP パラダイムがプログラマーに提供されます。

* アクターのシングル スレッド実行。Reliable Actor のランタイムは、アクターが同時に複数のスレッドを実行しないことを保証します。そのような理由から、また、アクターは互いに分離されるため、プログラマーはアクター レベルで同時実行に直面することがありません。プログラマーは、共有データへのアクセスを制御するために、ロックやその他の同期メカニズムを使用する必要がありません。この機能だけで、分散アプリケーションの開発が非熟練プログラマーでも扱いやすくなります。

* 透過的なアクティブ化。このランタイムは、処理するメッセージがある場合にのみ、必要に応じてアクターをアクティブにします。これにより、アプリケーションのコードによって認識されて制御されるアクターの論理的作成の概念と、アプリケーションに対して透過的なメモリ内でのアクターの物理的なアクティブ化が、明確に分離されます。Reliable Actors の手法は、アクターを「ページアウト」 (非アクティブ化)または「ページイン (アクティブ化)」するタイミングの決定で仮想メモリに似ています。ある時点で物理メモリ内にあるかどうかに関係なく、論理的に作成されたアクターの完全な「メモリ空間」にアプリケーションは中断なくアクセスできます。ハードウェア リソースのプールへのアクターの配置と移行により、透過的なアクティブ化は動的で適応型の負荷分散を可能にします。

* 場所の透過性。プログラマーがアクターのメソッドの呼び出しまたは他のコンポーネントへの受け渡しに使用するアクター参照 (プロキシ オブジェクト) には、アクターの論理 ID のみが含まれます。アクターの論理 ID から物理的な場所への変換および対応するメッセージのルーティングは、Reliable Actor ランタイムによって透過的に行われます。アプリケーション コードは、アクターの物理的な場所とは無関係にアクターと通信します。物理的な場所は、障害やリソース管理のため、時間の経過と共に変化する可能性があります。呼び出された時点でアクターが非アクティブ化されているためにアクターの場所が変わることもあります。

* 永続的なストアとの透過的な統合。Reliable Actors プログラミング モデルは、アクターのメモリ内の状態の永続的ストアへの宣言型マッピングに対応します。これは更新を同期化し、永続的な状態が正常に更新された後でのみ呼び出し元が結果を受け取ることを透過的に保証します。

* 高可用性、フェールオーバーのサポート、アプリケーション ライフサイクルの管理。Reliable Actorsの状態は、プラットフォームによって管理され、たとえばクラスター内のノードで障害が発生した場合に復元できるようにレプリケートされます。また、Service Fabric はアプリケーションのライフサイクルを管理し、ダウンタイムなしでアプリケーションをアップグレードできます。Reliable Actors プログラミング モデルは、アプリケーションまたはサービスの大幅な拡張の成功にプログラマーを導くように設計されています。これは、実績のあるベスト プラクティスとパターンを組み込み、下位レベルのシステム機能の効率的な実装を提供することによって実現されます。Service Fabric アプリケーションのスケーラビリティとパフォーマンスを可能にするいくつかの重要な要因を次に示します。

  * アプリケーションの状態の暗黙的なきめ細かい分割。アクターを直接対応可能なエンティティとして使用することにより、プログラマーはアプリケーションの全体的な状態を暗黙的に分割します。Reliable Actor のプログラミング モデルではアクターの大きさは規定されていませんが、通常は、比較的多数 (百万以上) のアクターを使用します。その百万単位のアクターのそれぞれがユーザー アカウントや注文といったアプリケーションの自然なエンティティを表します。アクターが個別処理可能であり、その物理的な場所がランタイムで抽象化されるとき、負荷分散とホット スポット処理は非常に柔軟になります。それは透過的かつ汎用的な方法で行われ、アプリケーション開発者は何も考える必要がありません。

  * 適応型のリソース管理。アクターはそれが対話する他のアクターの場所について何も想定しません。場所の透過性により、ランタイムは利用できるハードウェア リソースを非常に動的な方法で管理し、割り当てを調整できます。その際、入ってくる要求を落とすことなく、負荷と通信のパターンに対し、細かく決定した上でコンピューティング クラスター全体にアクターを配置し、移行します。特定のアクターの複数のレプリカを作成することで、ランタイムは、アプリケーションのコードを変更しなくても、アクターのスループットを向上させることができます。

  * 多重化通信。Service Fabric のアクターは論理エンドポイントを持ち、アクター間のメッセージは、すべて対すべての物理接続 (TCP ソケット) の固定セットによって多重化されます。これにより、このランタイムは、OS のオーバーヘッドなしでアクターごとに非常に多数 (数百万) のアドレス指定可能なエンティティをホストできます。さらに、アクターのアクティブ化/非アクティブ化では、TCP ポートや HTTP URL などの物理エンドポイントを登録/登録解除するコストは発生しません。

  * 効率的なスケジューリング。Reliable Actors のランタイムは、物理プロセッサ コアごとに 1 スレッドのカスタム スレッド プールにより多数のシングル スレッド アクターの実行をスケジュールします。非ブロッキング継続ベースの形式 (Reliable Actors のプログラミング モデルの必要条件) で記述されたアクターのコードでは、アプリケーション コードは競合のない非常に効率的な「協調」マルチスレッド方式で実行されます。これにより、システムは高スループットを達成し、きわめて安定した非常に高い CPU 使用率 (90 % 以上) で実行できます。システム内のアクターの数と負荷が増加してもスレッドまたは他の OS プリミティブが増えないことは、個々のノードとシステム全体のスケーラビリティの向上につながります。

  * 明示的な非同期性。Reliable Actors プログラミング モデルにより、分散アプリケーションの非同期的性質が明確になり、プログラマーが非ブロッキング非同期コードを作成する指針となります。これにより、マルチスレッドを明示的に使わずに、高い分散並列性と全体的スループットが実現されます。

<!---HONumber=AcomDC_0121_2016-->