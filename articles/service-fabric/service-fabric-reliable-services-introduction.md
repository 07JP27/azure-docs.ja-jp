---
title: Service Fabric の Reliable Services プログラミング モデルの概要 | Microsoft Docs
description: Service Fabric の Reliable Service プログラミング モデルについて学び、独自のサービスを作成しましょう。
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek; mani-ramaswamy

ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 03/25/2016
ms.author: masnider;vturecek

---
# Reliable Services の概要
Azure Service Fabric により、ステートレスおよびステートフルな Reliable Service の作成と管理が簡素化されます。このドキュメントでは、以下について説明します。

* ステートレス サービスおよびステートフル サービスの Reliable Services プログラミング モデル。
* Reliable Service を作成するうえでの選択肢。
* Reliable Service を使用するタイミングと作成方法のいくつかのシナリオと例。

Reliable Services は、Service Fabric で使用できるプログラミング モデルの 1 つです。Reliable Actors プログラミング モデルの詳細については、「[Service Fabric 高信頼アクターの概要](service-fabric-reliable-actors-introduction.md)」を参照してください。

Service Fabric では、サービスは構成およびアプリケーション コードで構成されますが、(オプションで) 状態を追加することもできます。

Service Fabric では、プロビジョニングとデプロイからアップグレードと削除までのサービスの有効期間が [Service Fabric のアプリケーション管理](service-fabric-deploy-remove-applications.md)で管理されます。

## Reliable Services について
Reliable Services は、重要な機能をアプリケーションに組み込むためのシンプルかつ強力な最上位レベルのプログラミング モデルを提供します。Reliable Services プログラミング モデルを使用すると、以下のことを実現できます。

* ステートフル サービスの場合、Reliable Services プログラミング モデルを使用すると、Reliable Collection によって状態がサービス内に一貫して確実に格納されます。Reliable Collection は、C# コレクションを使用したことがあるユーザーには馴染みのある可用性が高い一連のコレクション クラスです。これまでは、サービスにおいて確かな方法で状態を管理するには、外部システムが必要でした。Reliable Collection を使用すると、ユーザーのコンピューティングの隣に状態を格納できると同時に、高可用性の外部ストアと同じレベルの高い可用性と確実性を実現できます。また、コンピューティングと状態を併置することで遅延時間も短縮します。
* 使い慣れたプログラミング モデルに似た、独自のコードを実行するためのシンプルなモデル。コードには、適切に定義されたエントリ ポイントと管理が簡単なライフサイクルが含まれます。
* プラグ可能な通信モデル。HTTP と [Web API](service-fabric-reliable-services-communication-webapi.md)、WebSocket、カスタム TCP プロトコルなど、好みのトランスポートを使用できます。Reliable Services には、すぐに使用できる優れたオプションも用意されていますが、独自のオプションを指定することもできます。

## Reliable Services の特長
Service Fabric の Reliable Services は、これまでに作成したことがあるサービスとは異なります。Service Fabric は信頼性、可用性、整合性、およびスケーラビリティを提供します。

* **信頼性**: コンピューターの障害やネットワーク問題の発生などによって環境が悪化しても、サービスは維持されます。
* **可用性**: サービスはアクセス可能で、高い応答性があります(見つからないサービスや外部からアクセスできないサービスがないという意味ではありません)。
* **スケーラビリティ**: 特定のハードウェアからサービスを分離し、必要に応じて、ハードウェア リソースまたは仮想リソースを追加または削除することで拡張または縮小できます。サービスは、サービスの独立部分で個別にスケーリングしたり障害に対応したりできるように簡単に分割できます (特にステートフル サービスの場合)。最後に、Service Fabric では、数千単位のサービスをプロビジョニングする場合、すべての OS インスタンスを特定ワークロードの単一インスタンスに使用するのではなく 1 つのプロセスで実行できるため、軽量なサービスが作成される傾向があります。
* **整合性**: このサービスに格納されたすべての情報に一貫性があることが保証されます (これはステートフル サービスに限定されますが、詳細については後ほど説明します)。

## サービスのライフサイクル
サービスがステートフルかステートレスかにかかわらず、Reliable Services は、コードをすばやく追加して使用開始できるというシンプルなライフサイクルを提供します。サービスの稼動を開始するために実装する必要があるメソッドは 1 つまたは 2 つしかありません。

* **CreateServiceReplicaListeners/CreateServiceInstanceListeners**: サービスで使用される通信スタックがここで定義されます。この通信スタック ([Web API](service-fabric-reliable-services-communication-webapi.md) など) によって、サービスをリッスンするエンドポイント (クライアントによるアクセス方法) が定義されます。また、表示されるメッセージがサービス コードの残りの部分と最終的にやり取りする方法も定義されます。
* **RunAsync**: ここでサービスによってビジネス ロジックが実行されます。ここで提供されているキャンセル トークンは、そのサービス実行を停止する信号となります。たとえば、常に Reliable Queue からメッセージを取得して処理する必要があるサービスがある場合、ここでサービスが実行されます。

### サービスのスタートアップ
Reliable Service のライフサイクル内での主要イベントを次に示します。

1. サービス オブジェクト (ステートレス サービスまたはステートフル サービスから派生したもの) が構築されます。
2. `CreateServiceReplicaListeners`/`CreateServiceInstanceListeners` メソッドが呼び出されると、1 つ以上の通信リスナーを返すことができます。
   
   * これはオプションですが、ほとんどのサービスで一部のエンドポイントが直接公開されます。
3. 通信リスナーは、作成された時点で開始されます。
   
   * 通信リスナーに含まれる `OpenAsync()` と呼ばれるメソッドはこの時点で呼び出され、サービスのリスニング アドレスを返します。組み込まれている ICommunicationListener の 1 つを Reliable Service で使用した場合、この処理はサービス側で実行されます。
4. 通信リスナーが開始されると、主要サービスで `RunAsync()` メソッドが呼び出されます。
   
   * `RunAsync()` はオプションであることに注意してください。サービスがユーザーの呼び出しにのみ応答してすべての処理を直接実行する場合、`RunAsync()` を実装する必要はありません。

### サービスのシャットダウン
サービスを (削除、アップグレード、移動するために) シャットダウンする場合、呼び出しの順序は逆になります。最初に `RunAsync()` によって保持された取り消しトークンがキャンセルされ、次に通信リスナーで `CloseAsync()` が呼び出されます。

ステートフル サービスのシャットダウンに関する重要な注意事項がいくつかあります。

* `CloseAsync` と `RunAsync` が返されるまで、Service Fabric はサービスの別のレプリカをプライマリの状態に昇格しません。組み込みの通信リスナーを使用している場合、`CloseAsync` メソッドはサービス側で実行されます。
* これらのメソッドから制御が戻るときに時間制限はありませんが、Reliable Collection への書き込みはすぐにできなくなるため、実際の処理を完了できません。取り消し要求を受信したらできるだけ短時間で制御が戻るようにすることをお勧めします。

## サービスの例
このプログラミング モデルを理解した上で、2 つのサービスを見ながら、これらがどのように機能するかを説明します。

### ステートレス Reliable Service
ステートレス サービスは、文字どおりサービス内で状態が保持されないサービス、または存在する状態が完全に破棄可能なため同期、レプリケーション、永続化、または高可用性を必要としないサービスです。

たとえば、メモリのない電卓が、同時に処理する必要があるすべての項と演算を受け取る場合を考えてみてください。

この場合は、サービスの RunAsync() を空にしておくことができます。これは、サービスが実行する必要のあるバック グラウンドのタスク処理がないためです。電卓サービスを作成すると、ICommunicationListener (たとえば [Web API](service-fabric-reliable-services-communication-webapi.md)) が返され、このメソッドが任意のポートでリッスン エンドポイントを開始します。このリッスン エンドポイントは、電卓のパブリック API を定義するさまざまなメソッド (例: "Add (n1, n2)") に接続します。

クライアントから呼び出しが行われた場合は、適切なメソッドが呼び出され、電卓サービスは提供されたデータに対する演算を実行して、結果を返します。この処理では、状態はまったく保存されません。

内部の状態がまったく保存されないため、この電卓の例は非常にシンプルです。ただし、大半のサービスは実際にはステートレスではありません。状態が外部ストアに格納されているためです(たとえば、セッション状態をバッキング ストアまたはキャッシュに保持している任意の Web アプリは、完全にステートレスというわけではありません)。

Service Fabric でのステートレス サービスの使用方法を示す一般的な例は、Web アプリケーションの公開 API を公開するフロントエンド サービスです。フロントエンド サービスは、ステートフル サービスと通信してユーザーの要求を完了します。この場合、クライアントからの呼び出しは、ポート 80 など、ステートレス サービスがリッスンしている既知のポートに送られます。このステートレス サービスは呼び出しを受信し、その呼び出しが信頼できる利用者からのものかどうか、またどのサービスに向けて送信されたのかを判断します。次にステートレス サービスは、その呼び出しをステートフル サービスの正しいパーティションに転送して、応答を待ちます。ステートレス サービスは、応答を受信すると、元のクライアントに応答します。

### ステートフル Reliable Service
ステートフル サービスは、サービス提供するために、状態の一部の整合性を維持して永続化しておかなければならないサービスです。受け取る最新情報に基づいて値の移動平均を常に計算するサービスを考えてみてください。このサービスを提供するには、最新の平均のほかに、処理する必要がある一連の現在の受信要求が必要になります。情報を取得、処理して、外部ストア (現時点では Azure BLOB やテーブル ストアなど) に格納するサービスはどれもステートフル サービスです。その状態は外部の状態ストアに保持されます。

現在のほとんどのサービスでは状態が外部ストアに格納されますが、その理由は、その状態の信頼性、可用性、スケーラビリティ、および整合性を提供できるのが外部ストアであるためです。Service Fabric では、ステートフル サービスで状態を外部ストアに格納することは求められていません。サービス コードとサービス状態の両方についてこれらの要件が Service Fabric 側で満たされているためです。

たとえば、イメージで実行する必要がある一連の変換要求と、変換する必要があるイメージを受け取るサービスを作成するとします。このようなサービスの場合、通信リスナー (Web API とします) が返されます。この通信リスナーにより、通信ポートが開かれ、`ConvertImage(Image i, IList<Conversion> conversions)` のような API を使用した送信が可能になります。この API では、サービスが情報を取得して要求を Reliable Queue に格納してから、クライアントに何らかのトークンを返すことで、この要求を追跡できるようになります (要求に時間がかかる場合があるため)。

このサービスでは、RunAsync が複雑になる可能性があります。その理由は、IReliableQueue から要求を取得し、リストされた変換を実行して、その結果を IReliableDictionary に格納するというループが RunAsync 内に追加されるためです。これによって、クライアントは戻ってきたときに、変換されたイメージを取得できます。何らかの障害が発生した場合でもイメージが失われないように、この Reliable Service では情報がキューから取得され、変換された後に結果がトランザクションに格納されます。この場合、キューから実際に削除されるのはメッセージのみで、変換が完了すると結果は結果ディクショナリに格納されます。途中で障害が発生した場合 (コードのこのインスタンスが実行されているマシンなどで)、要求はキューに残ったままで、再度処理されるのを待ちます。

このサービスの注目すべき点は、これらの処理が通常の .NET サービスに似ているということです。唯一異なる点は、使用されているデータ構造 (IReliableQueue および IReliableDictionary) が Service Fabric によって提供されているため、信頼性、可用性、および整合性が高いということです。

## Reliable Services API を使用するタイミング
ご使用のアプリケーション サービスのニーズが次のいずれかに当てはまる場合は、Reliable Services API を検討してください。

* 複数の状態に対するアプリケーションの動作を提供する必要がある (例: 注文や注文品目)。
* アプリケーションの状態を、Reliable Dictionary と Reliable Queue として自然にモデル化することができる。
* 状態の可用性を高め、アクセスの待機時間を短くする必要がある。
* アプリケーションでは、1 つ以上の Reliable Collection に対して、トランザクション操作の同時実行または粒度を制御する必要がある。
* サービスの通信を管理するか、パーティション構成を制御したい。
* コードにはフリー スレッドの実行時環境が必要である。
* アプリケーションでは、実行時に Reliable Dictionary または Reliable Queue を動的に作成または破棄する必要がある。
* サービスの状態について、Service Fabric が提供するバックアップ機能および復元機能をプログラムによって制御する必要がある*。
* アプリケーションで、複数の状態に関する変更履歴を維持する必要がある*。
* カスタム状態プロバイダーを開発するか、サード パーティが開発したカスタム状態プロバイダーを使用したい*。

> [!NOTE]
> *SDK で利用できる機能で一般公開されているもの。
> 
> 

## 次のステップ
* [Reliable Services のクイック スタート](service-fabric-reliable-services-quick-start.md)
* [Reliable Services の詳細な使用方法](service-fabric-reliable-services-advanced-usage.md)
* [Reliable Actors プログラミング モデル](service-fabric-reliable-actors-introduction.md)

<!---HONumber=AcomDC_0406_2016-->