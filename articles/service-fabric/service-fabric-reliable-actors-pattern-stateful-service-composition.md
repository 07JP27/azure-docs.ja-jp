
<properties
   pageTitle="ステートフル サービス構成パターン | Microsoft Azure"
   description="サービス呼び出しの間の状態を維持したり、前のサービスの結果をキャッシュしたりするための、ステートフル アクターを使用する Service Fabric Reliable Actors の設計パターン"
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/05/2015"
   ms.author="vturecek"/>

# Reliable Actors の設計パターン: ステートフル サービスの構成

開発者は 10 年半を費やし、企業に N 階層のステートレス サービスを構築してきました。データベースの上にサービスを構築しました。その他のサービスの上に上位サービスを構築しました。そしてそれらのサービスを調整するために、オーケストレーション エンジンとメッセージ指向ミドルウェアを構築しました。対話機能や拡張性に対する要求が厳しくなり、ユーザーのワークロードが増えるにつれて、ステートレス サービス指向アーキテクチャ (SOA) の欠点が見え始めました。

## 従来の方法: SOA サービス

SOA サービスはステートレスな性質により水平方向にシームレスに拡張しましたが、ストレージ層に同時実行性とスループットというボトルネックが発生しました。それにより、ストレージへのアクセスがますます高額になりました。一般的な方法として、ほとんどの開発者はストレージに対する要求を減らすためにソリューションにキャッシュを導入しました。ただし、そのソリューションに欠点がないわけではありませんでした。キャッシュする同時アクセス、セマンティックな制限と変更、一貫性を管理する別の層を必要としました。[スマート キャッシュのパターン](service-fabric-reliable-actors-pattern-smart-cache.md)で詳しく説明したように、仮想のアクターのモデルがこれらの問題に対する完全なソリューションを提供します。ストレージ層をレプリケートすることで SOA 問題を解決しようとした開発者もいます。しかしながら、その方法では拡張性が十分ではありません。Common Alerting Protocol (共通警報プロトコル) 境界にすぐに到達します。

2 番目の問題は、変化する要件に関する問題です。ユーザーも企業も、基準として、秒単位ではなくミリ秒単位で応答できる対話型サービスを要求します。その要求を満たすために、開発者は他のサービスの上にファサード サービスの構築を始めました。多数のファサード サービスでユーザー中心のサービスを構築することもありました。しかしながら、ダウンストリーム サービスを多く追加すると、すぐに待ち時間の問題が発生します。

開発者はまた、キャッシュとメモリ内オブジェクト ストアに合わせ、調整しました。場合によっては、パフォーマンス要件を満たすためにさまざまな実装を利用しました。この方法では、開発者は一般的にバックエンド worker プロセスを構築し、定期的にキャッシュを作成します。高額なオンデマンド キャッシュ入力が最小限に抑えられます。それから、ワークロードを分解し、同期操作と非同期操作を分離します。それにより、対話操作のためのリソースが増え、(SOA で特に難しい問題である) ステートの変化に対応できます。

多くの場合、キューや worker など、追加の層も導入します。それによりソリューションがさらに複雑になることがあります。

開発者は、基本的には、"ステートフル サービス" を構築する、つまり、"状態" と "サービスの動作" を結び付けて、ユーザー中心の対話的エクスペリエンスに対処するソリューションを探しています。そこで目を付けたのが、サービスの置換ではなく、サービス構成階層を挿入する Azure Service Fabric Reliable Actors モデルです。

次の図は、このポイントを示しています。

![Reliable Actors、サービス構成、状態の永続性][1]

## アクターでより優れたソリューションを実装する

サービスを構成する場合、アクターはステートレスにもステートフルにもできます。

* ステートレス アクターは、基になるサービスのプロキシとして使用できます。このアクターは、Service Fabric のクラスター間で動的に拡張し、サービスに関連する特定の情報をキャッシュできます。検出後、そのエンドポイントが含まれる場合があります。
* ステートフル アクターは、サービス呼び出しの間の状態を維持したり、前のサービスの結果をキャッシュしたりできます。状態は永続化することも一時的にすることもできます。

このパターンは多くのシナリオに適用されます。ほとんどの場合、特定のサービスで操作を呼び出すために、アクターは外部通話を行う必要があります。最近の電子商取引アプリケーションを例にこれを説明してみます。そのようなアプリケーションは、ユーザー プロファイル管理、推奨事項、買い物かごの管理、ウィッシュ リストの管理、購買などのさまざまな機能を提供するサービスで構築されます。

ほとんどの電子商取引開発者は、ソーシャル エクスペリエンスの開発と同じく、ユーザー中心の手法をアーキテクチャに採用します。それは電子商取引も主にユーザーと商品を中心に発展するためです。通常、開発者ソリューションはサービスのファサードを配布することで実現します。ほとんどの場合、パフォーマンス上の理由により、キャッシュによりサポートされます。

アクター ベースの手法と比較してください。ユーザー アクターはユーザーの行動を表します (カタログを閲覧する、商品を希望する、商品をかごに追加する、商品を友人に勧めるなど)。しかしながら、ユーザーに対して組み立てられた状態も表します。ユーザーのプロファイル、かごの中の商品、友人が勧めた商品、ユーザーの購入履歴、ユーザーが現在住んでいる地域情報などです。

## ステートフル アクターを使用して状態を入力する

最初に、ユーザーのアクターが複数のサービスから状態を取り込む必要がある例を見てみましょう。[スマート キャッシュのパターン](service-fabric-reliable-actors-pattern-smart-cache.md)で説明した内容がすべてここでも適用されるため、これについてのコード サンプルは提供しません。ユーザー アクターはサインイン時に起動し、バックエンド サービスから十分なデータをそれに入力できます。状態の全部または一部を必要なときに、またはタイマーを設定して、あるいはその両方で入力することもできます。これはアクターにキャッシュで着ます。この例では、**プロファイル**と**ウィッシュ リスト**を次に示します。

![プロファイルとウィッシュ リストのサービス][2]

開発者は、アクセスの多いユーザーの状態を事前入力し、サインイン時にすぐに使えるように用意できます。開発者はまた、ユーザーが毎月サービスにアクセスする場合、そのサインイン時に状態を入力できます。このパターンはスマート キャッシュのセクションにもあります。

(上の画像の) User 23 がログオンしたとき、ユーザー アクター (23) がまだ起動していなければ起動します。ユーザー アクターは関連するユーザー プロファイル情報とウィッシュ リストをバックエンド サービスからフェッチします。ユーザー アクターが後続の呼び出しのために情報をキャッシュする場合もあります。たとえば、商品をウィッシュ リストに追加する必要がある場合、前に説明したように、ライト ビハインドやライト スルーで追加できます。

それではユーザーが気に入った商品の**いいね**ボタンをクリックする例を見てみましょう。このアクションでは、場合によっては、複数のサービスが複数回呼び出されます。このようなアクションには、「いいね」をカタログ サービスに送信する、次の一連の推奨項目を起動する、更新をソーシャル ネットワークに投稿するなどがあります。

その例を次に示します。

![商品にいいねを付ける、ウィッシュ リスト、プロファイル、カタログ サービス][3]

## 構成と非同期通信にアクターを利用する
Service Fabric Reliable Actors プログラミング モデルは、開発者が要求/応答形式の操作と非同期操作を一緒に構成するときに便利です。たとえば、ある商品に「いいね」を付けるとその商品がすぐにユーザーのウィッシュ リストに追加され、バッファーとタイマーを利用して非同期にソーシャル ネットワークに投稿され、次の一連の推奨操作が起動します。

サービスにユーザー アクターを利用することのもう 1 つの大きな利点に、アクターはキャッシュされた状態に自然な場所を提供することです。最も重要なことですが、アクターはまた、その状態の変化に非同期で対応します。これは、ステートレス サービスでは特に難しいシナリオです。たとえば、ユーザーは「ユーザー体験」の一部として一連のアクションを実行し、それらのイベントをアクターにリアルタイムで記録できます。ストリームを組み立て、イベント時間に、またはタイマーで非同期に問い合わせ、アクターの行動を変更できます。

エンドポイントが言語非依存のプロトコルで公開されているため、SOA の純正主義者なら、この時点でこれらがアクターのサービスでないことに間違いなく気づくでしょう。Service Fabric Reliable Actors モデルは相互運用性コンポーネントでもサービスの相互運用性のためのプラットフォームでもありません。それでもやはり、アクターをモデル化したり、同じ方法で関心の分離をモデル化したりするときに、どうしても SOA 型サービスの粒度の観点から考えてしまいます。そのようなサービスは「マイクロサービス」と呼ばれます。Service Fabric Reliable Actors の前に相互運用層として REST や SOAP エンドポイントを配置することも開発者は止められません。

また、ステートフル サービスの構成は、e コマースなどのトランザクションのシナリオだけでなく、ワークフローにも適用されます。Service Fabric は、ワークフロー/オーケストレーション エンジンとして設計されています。サービスとやりとりし、そのやりとりの状態を保持するワークフローのモデル化に利用できます。

動的なエクスペリエンスを提供するためのスケーラブルなサービスの構築では「ステートレス サービス」の欠点がわかります。Service Fabric Reliable Actors プログラミング モデルは、状態と動作をまとめ、開発者が既存の投資の上にスケーラブルで対話型のエクスペリエンスを構築できるように支援します。


## 次のステップ

[パターン: スマート キャッシュ](service-fabric-reliable-actors-pattern-smart-cache.md)

[パターン: 分散ネットワークとグラフ](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[パターン: リソースのガバナンス](service-fabric-reliable-actors-pattern-resource-governance.md)

[パターン: モノのインターネット](service-fabric-reliable-actors-pattern-internet-of-things.md)

[パターン: 分散計算](service-fabric-reliable-actors-pattern-distributed-computation.md)

[いくつかのアンチパターン](service-fabric-reliable-actors-anti-patterns.md)

[Service Fabric Reliable Actors の概要](service-fabric-reliable-actors-introduction.md)


<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-1.png
[2]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-2.png
[3]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-3.png

<!---HONumber=AcomDC_0121_2016-->