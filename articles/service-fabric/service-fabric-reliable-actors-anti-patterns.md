<properties
   pageTitle="Azure Service Fabric アクターのいくつかの問題点 | Microsoft Azure"
   description="Azure Service Fabric アクターを学習しているお客様が陥りやすいいくつかの問題点"
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/11/2015"
   ms.author="vturecek"/>

# Reliable Actors の設計パターン: いくつかのアンチパターン

Service Fabric Reliable Actors を学習しているユーザーが陥りやすい問題点を次に示します。

* Reliable Actors をトランザクション システムとして扱う。Service Fabric Reliable Actors は、不可分性、一貫性、独立性、および永続性 (ACID) を提供する 2 フェーズのコミットベースのシステムではありません。オプションの永続化を実装せず、アクターが実行されているマシンが強制終了された場合、その現在の状態も共に失われます。アクターは非常に迅速に別のノードに切り替わりますが、永続化のサポートを実装していない限り、その状態は失われます。ただし、再試行、重複フィルター処理、およびべき等設計を活用して、高レベルの信頼性と一貫性を実現できます。

* ブロック。Reliable Actors で実行するすべての操作は、非同期である必要があります。現在、Microsoft プラットフォームでは非同期 API が豊富に提供されているため、このような操作は通常は簡単です。ただし、ブロック API のみを提供するシステムと対話する必要がある場合、.NET スレッド プールを明示的に使用するラッパー内に含める必要があります。

* 環境を十分に設計し、機能するようにします。同時の収集やロックについて心配したり、ツールを使用して XML からオブジェクトをコンパイルしたりすることに慣れている開発者にとって、変数への値の割り当てや作業のスケジュール設定など、単純な操作を行うクラスを単にコーディングすることには抵抗があるかもしれません。スケジュールされたタスクが組み込まれているので、ロックは必要ありません。状態は重要な問題とはなりません。大規模な環境で多数のサーバー側作業を完了したことがある管理者であれば、慣れている可能性があります。

* 単一のアクターをボトルネックにする。数百万ものアクターを別のアクターの単一のインスタンスに集中させることで、このような状況に陥りがちです。[分散計算のデザイン パターンの](service-fabric-reliable-actors-pattern-distributed-computation.md)で示した集計アプローチを使用してください。

* エンティティ モデルを無条件にマップする。これは、エンティティとそのリレーションシップを使用して問題がモデル化されるリレーショナル環境にいた開発者が陥りやすい問題点です。このアプローチは、サブジェクト ドメインを理解するために今なお役立ちますが、サービス指向の考え方と組み合わせ、動作と調和させる必要があります。

<!---HONumber=AcomDC_0121_2016-->