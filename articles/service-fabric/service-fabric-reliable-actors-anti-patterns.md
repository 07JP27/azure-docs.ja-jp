<properties
   pageTitle="いくつかの Azure Service Fabric アクターのアンチパターン"
   description="Azure Service Fabric アクターを学習しているお客様が陥りやすいいくつかの問題点"
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="03/17/2015"
   ms.author="claudioc"/>

# Service Fabric の設計パターン: いくつかアンチパターン

Azure Service Fabric アクターを学習しているお客様が陥りやすい問題点を次に示します。

* Azure Service Fabric アクターをトランザクション システムとして扱う。Azure Service Fabric アクターは、ACID を提供する 2 フェーズのコミット ベース システムではありません。オプションの永続化を実装せず、アクターが実行されているマシンが強制終了された場合、その現在の状態も共に失われます。アクターは非常に迅速に別のノードに切り替わりますが、永続化のサポートを実装していない限り、その状態は失われます。ただし、再試行、重複フィルター処理、およびべき等設計を活用する間に、高レベルの信頼性と一貫性を実現できます。

* ブロック。Azure Service Fabric アクターで実行するすべての操作は、非同期である必要があります。現在、Microsoft プラットフォームでは非同期 API が豊富に提供されているため、このような操作は通常は簡単です。ただし、何らかの理由で、ブロッキング API のみを提供するシステムと対話する必要がある場合は、.NET スレッド プールを明示的に使用するラッパー内にこのシステムを配置する必要があります。

* 過剰なアーキテクト。環境を活用してください。同時の収集やロックについて心配したり、ツールを使用して XML からオブジェクトをコンパイルしたりすることに慣れている開発者にとって、変数への値の割り当てや作業のスケジュール設定など、単純な操作を行うクラスを単にコーディングすることには抵抗があるかもしれません。スケジュールされたタスクが既に組み込まれています。ロックは必要はありません。状態は重要な問題とはなりません。大規模な環境でサーバー側の作業を多量に行ってきた多くのユーザーにとっては、多少の慣れが必要です。

* 単一のアクターをボトルネックにする。数百万ものアクターを別のアクターの単一のインスタンスに集中させることで、このような状況に陥りがちです。[分散計算のデザイン パターンの](service-fabric-reliable-actors-pattern-distributed-computation.md)で示した集計アプローチを使用してください。

* エンティティ モデルを無条件にマップする。これは、エンティティとそのリレーションシップを使用して問題がモデル化されるリレーショナル環境にいた開発者が陥りやすい問題点です。このアプローチは、サブジェクト ドメインを理解するために今なお役立ちますが、サービス指向の考え方と組み合わせ、動作と調和させる必要があります。
 

<!---HONumber=July15_HO2-->