<properties
   pageTitle="Service Fabric クラスター リソース マネージャー - アフィニティ | Microsoft Azure"
   description="Service Fabric サービスの追加の配置ポリシーとルールの概要"
   services="service-fabric"
   documentationCenter=".net"
   authors="masnider"
   manager="timlt"
   editor=""/>

<tags
   ms.service="Service-Fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="03/10/2016"
   ms.author="masnider"/>

# Service Fabric でアフィニティを構成し、使用する

アフィニティは、少なくとも一見すると、マイクロサービスの環境ではあまり意味がありません。あまり意味がないのは、それがマイクロサービスの環境であるためです。アフィニティは主に、以前の大規模なモノリシック アプリケーションをクラウドとマイクロサービスの世界に移行しやすくするために提供されるコントロールです。

たとえば、大規模なアプリや、マイクロサービスでの使用を想定していないアプリを Service Fabric に移行するとしましょう。実際、このような状況はとても多く、これまでに複数の顧客 (内部、外部とも) が経験してきました。まずは、アプリ全体を環境に移行し、パッケージ化して実行するところから始めます。次に、すべてが相互に通信する小規模なサービスにアプリを分解します。

ここで、困ったことが起こります。“困ったこと” は、通常、次のいずれかに分類されます。

1. モノリシック アプリのコンポーネント X と、サービスに変換し、クラスター間で移動したばかりのコンポーネント Y の間にドキュメントに未記載の依存関係があることが判明した。これが壊れている。
2.	通信は (ローカルの名前付きパイプ | 共有メモリー | ディスク上のファイル) を介して行われるが、処理スピードを速めるため、個別に更新できるようにしたい。
3.	すべて問題ないが、これら 2 つのコンポーネント間の通信が非常に多かったり、パフォーマンスに影響しやすかったりするため、別々のサービスに分解すると、パフォーマンスが低下することが判明した。

どのケースでも、リファクタリング作業を断念することや、モノリシックに戻すことは望ましくありません。しかし、問題が解決されるまでは、あたかもローカルであると “感じられる” ように、状況を元に戻したいと考えています。

どうすればよいでしょうか。 そこで、アフィニティを有効にします。

## アフィニティのしくみ
アフィニティを設定するには、2 つのサービスの間にアフィニティの関係を定義します。通常、これは一方のサービスから別のサービスを “ポイント” し、“このサービスはそのサービスの実行中にだけ実行できる“ と示すことと考えることができます。 これを親子関係と呼ぶ場合もあります (親から子をポイントする)。親子関係を示すことで、サービスのレプリカまたはインスタンスが、それに関連付けられているサービスのレプリカまたはインスタンスと同じノード上に配置されるようになります。

``` csharp
ServiceCorrelationDescription affinityDescription = new ServiceCorrelationDescription();
affinityDescription.Scheme = ServiceCorrelationScheme.Affinity;
affinityDescription.ServiceName = new Uri("fabric:/otherApplication/parentService");
serviceDescription.Correlations.Add(affinityDescription);
await fabricClient.ServiceManager.CreateServiceAsync(serviceDescription);
```

## アフィニティのさまざまなオプション
アフィニティは、いくつかの相関スキームのいずれかで表され、2 種類のモードがあります。アフィニティの最も一般的なモードは、NonAlignedAffinity と呼ばれるものです。NonAlignedAffinity では、異なるサービスのレプリカまたはインスタンスが同じノード上に配置されます。もう 1 つのモードは、AlignedAffinity です。Aligned Affinity は、ステートフル サービスで使用します。あるステートフル サービスに別のステートフル サービスで整列したアフィニティが含まれるように構成すると、これらのサービスのプライマリがペアで同じノード上に配置され、セカンダリの各ペアも同じノードに配置されます。ステートフル サービスに対して NonAlignedAffinity を構成することもできます (ただし、あまり一般的ではありません)。この場合、ステートレス サービスの場合とほぼ同じ動作になります。2 つのステートフル サービスの異なるレプリカが同じノード上に配置されますが、プライマリとセカンダリが同じノードに配置されることはありません。

![アフィニティのモードとその影響][Image1]

### ベスト エフォートの望まれる状態
アフィニティとモノリシックなアーキテクチャにはいくつかの違いがあります。そのほとんどは、アフィニティの関係がベスト エフォートであるという事実に集約されます。それらは根本的に異なるサービスであるため、たとえば個別にエラーが発生する場合があります。容量制限などで、サービスの異なるレプリカが分離することもあります。


### チェーンと星
現在、アフィニティの関係のチェーンをモデル化することはできません。これは、あるアフィニティの関係で子になっているサービスは、別のアフィニティの関係では親になれないことを意味します。つまり、このような関係をモデル化する場合、最下位の子の親になるのではなく、子の "中央" にいる親になることで、実質的にはチェーンではなく星としてモデル化する必要があることを意味します。

![アフィニティの関係のコンテキストにおけるチェーンと星][Image2]

アフィニティの関係について注目すべきもう 1 つの点は、方向があるということです。これは些細なことですが、実質的に意味することは、子は親と同じ場所にあるということを強制するのは “アフィニティ” のルールのみであり、親が別のノードにフェール オーバーした (または親の動作のみを強制するその他の限定的アクションの) 場合、リソース マネージャーは子が親と同じ場所にないことが通知されるまで、異常に気付きません。つまり、関係はすぐには適用されません。

### パーティション分割のサポート
アフィニティについて注目すべき最後の点は、親がパーティション分割されている場合、アフィニティの関係がサポートされないということです。これは、最終的にはサポートされる可能性がありますが、今のところ許可されていません。

## 次のステップ
- サービスの公正で利用できるその他のオプションに関する詳細については、「[サービスの構成について学習する](service-fabric-cluster-resource-manager-configure-services.md)」にあるその他のクラスター リソース マネージャーに関するトピックを参照してください。

[Image1]: ./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resrouce-manager-affinity-modes.png
[Image2]: ./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resource-manager-chains-vs-stars.png

<!---HONumber=AcomDC_0316_2016-->